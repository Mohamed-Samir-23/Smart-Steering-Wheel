
Application1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08003400  08003400  00003400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000118c  08003530  08003530  00003530  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000004  080046bc  080046bc  000046bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080046c0  080046c0  00010008  2**0
                  CONTENTS
  4 .ARM          00000000  080046c0  080046c0  00010008  2**0
                  CONTENTS
  5 .preinit_array 00000000  080046c0  080046c0  00010008  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080046c0  080046c0  000046c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080046c4  080046c4  000046c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000008  20000000  080046c8  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000160  20000008  080046d0  00010008  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000168  080046d0  00010168  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00010008  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00010031  2**0
                  CONTENTS, READONLY
 13 .debug_info   00002318  00000000  00000000  00010074  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000a22  00000000  00000000  0001238c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000290  00000000  00000000  00012db0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000001ce  00000000  00000000  00013040  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00000f80  00000000  00000000  0001320e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000172c  00000000  00000000  0001418e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0000511f  00000000  00000000  000158ba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00000858  00000000  00000000  0001a9dc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000063  00000000  00000000  0001b234  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08003530 <__do_global_dtors_aux>:
 8003530:	b510      	push	{r4, lr}
 8003532:	4c05      	ldr	r4, [pc, #20]	; (8003548 <__do_global_dtors_aux+0x18>)
 8003534:	7823      	ldrb	r3, [r4, #0]
 8003536:	b933      	cbnz	r3, 8003546 <__do_global_dtors_aux+0x16>
 8003538:	4b04      	ldr	r3, [pc, #16]	; (800354c <__do_global_dtors_aux+0x1c>)
 800353a:	b113      	cbz	r3, 8003542 <__do_global_dtors_aux+0x12>
 800353c:	4804      	ldr	r0, [pc, #16]	; (8003550 <__do_global_dtors_aux+0x20>)
 800353e:	f3af 8000 	nop.w
 8003542:	2301      	movs	r3, #1
 8003544:	7023      	strb	r3, [r4, #0]
 8003546:	bd10      	pop	{r4, pc}
 8003548:	20000008 	.word	0x20000008
 800354c:	00000000 	.word	0x00000000
 8003550:	080046a4 	.word	0x080046a4

08003554 <frame_dummy>:
 8003554:	b508      	push	{r3, lr}
 8003556:	4b03      	ldr	r3, [pc, #12]	; (8003564 <frame_dummy+0x10>)
 8003558:	b11b      	cbz	r3, 8003562 <frame_dummy+0xe>
 800355a:	4903      	ldr	r1, [pc, #12]	; (8003568 <frame_dummy+0x14>)
 800355c:	4803      	ldr	r0, [pc, #12]	; (800356c <frame_dummy+0x18>)
 800355e:	f3af 8000 	nop.w
 8003562:	bd08      	pop	{r3, pc}
 8003564:	00000000 	.word	0x00000000
 8003568:	2000000c 	.word	0x2000000c
 800356c:	080046a4 	.word	0x080046a4

08003570 <APARES_AsciToHex>:

u8 APARES_AsciToHex
(
	u8 ARG_u8Asci
)
{
 8003570:	b480      	push	{r7}
 8003572:	b085      	sub	sp, #20
 8003574:	af00      	add	r7, sp, #0
 8003576:	4603      	mov	r3, r0
 8003578:	71fb      	strb	r3, [r7, #7]
	u8 L_u8Result;
	if ( (ARG_u8Asci >= 48) && (ARG_u8Asci <= 57) )
 800357a:	79fb      	ldrb	r3, [r7, #7]
 800357c:	2b2f      	cmp	r3, #47	; 0x2f
 800357e:	d906      	bls.n	800358e <APARES_AsciToHex+0x1e>
 8003580:	79fb      	ldrb	r3, [r7, #7]
 8003582:	2b39      	cmp	r3, #57	; 0x39
 8003584:	d803      	bhi.n	800358e <APARES_AsciToHex+0x1e>
	{
		L_u8Result = ARG_u8Asci - 48;
 8003586:	79fb      	ldrb	r3, [r7, #7]
 8003588:	3b30      	subs	r3, #48	; 0x30
 800358a:	73fb      	strb	r3, [r7, #15]
 800358c:	e002      	b.n	8003594 <APARES_AsciToHex+0x24>
	}
	else
	{
		L_u8Result = ARG_u8Asci - 55;
 800358e:	79fb      	ldrb	r3, [r7, #7]
 8003590:	3b37      	subs	r3, #55	; 0x37
 8003592:	73fb      	strb	r3, [r7, #15]
	}

	return L_u8Result;
 8003594:	7bfb      	ldrb	r3, [r7, #15]
}
 8003596:	4618      	mov	r0, r3
 8003598:	3714      	adds	r7, #20
 800359a:	46bd      	mov	sp, r7
 800359c:	bc80      	pop	{r7}
 800359e:	4770      	bx	lr

080035a0 <APARES_voidData>:

STD_error_t APARES_voidData
(
	volatile u8* ARG_Pu8Data
)
{
 80035a0:	b580      	push	{r7, lr}
 80035a2:	b086      	sub	sp, #24
 80035a4:	af00      	add	r7, sp, #0
 80035a6:	6078      	str	r0, [r7, #4]
	STD_error_t L_stderrorError=E_NOK;
 80035a8:	2300      	movs	r3, #0
 80035aa:	75fb      	strb	r3, [r7, #23]
	
	if(ARG_Pu8Data != NULL_POINTER )
 80035ac:	687b      	ldr	r3, [r7, #4]
 80035ae:	2b00      	cmp	r3, #0
 80035b0:	f000 80b6 	beq.w	8003720 <APARES_voidData+0x180>
	{
		u8 L_u8DigitLow,L_u8DigitHigh,L_u8CC,L_u8I;
		u8 L_u8DataDigit0,L_u8DataDigit1,L_u8DataDigit2,L_u8DataDigit3;
		u8 L_u8DataCounter = 0;
 80035b4:	2300      	movs	r3, #0
 80035b6:	757b      	strb	r3, [r7, #21]

		/* Get Character Count */
		L_u8DigitHigh = APARES_AsciToHex (ARG_Pu8Data[1]);
 80035b8:	687b      	ldr	r3, [r7, #4]
 80035ba:	3301      	adds	r3, #1
 80035bc:	781b      	ldrb	r3, [r3, #0]
 80035be:	b2db      	uxtb	r3, r3
 80035c0:	4618      	mov	r0, r3
 80035c2:	f7ff ffd5 	bl	8003570 <APARES_AsciToHex>
 80035c6:	4603      	mov	r3, r0
 80035c8:	753b      	strb	r3, [r7, #20]
		L_u8DigitLow  = APARES_AsciToHex (ARG_Pu8Data[2]);
 80035ca:	687b      	ldr	r3, [r7, #4]
 80035cc:	3302      	adds	r3, #2
 80035ce:	781b      	ldrb	r3, [r3, #0]
 80035d0:	b2db      	uxtb	r3, r3
 80035d2:	4618      	mov	r0, r3
 80035d4:	f7ff ffcc 	bl	8003570 <APARES_AsciToHex>
 80035d8:	4603      	mov	r3, r0
 80035da:	74fb      	strb	r3, [r7, #19]
		L_u8CC = (L_u8DigitHigh<<4) | L_u8DigitLow ;
 80035dc:	7d3b      	ldrb	r3, [r7, #20]
 80035de:	011b      	lsls	r3, r3, #4
 80035e0:	b25a      	sxtb	r2, r3
 80035e2:	f997 3013 	ldrsb.w	r3, [r7, #19]
 80035e6:	4313      	orrs	r3, r2
 80035e8:	b25b      	sxtb	r3, r3
 80035ea:	74bb      	strb	r3, [r7, #18]

		/* Get Address */
		L_u8DataDigit0 = APARES_AsciToHex (ARG_Pu8Data[3]);
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	3303      	adds	r3, #3
 80035f0:	781b      	ldrb	r3, [r3, #0]
 80035f2:	b2db      	uxtb	r3, r3
 80035f4:	4618      	mov	r0, r3
 80035f6:	f7ff ffbb 	bl	8003570 <APARES_AsciToHex>
 80035fa:	4603      	mov	r3, r0
 80035fc:	747b      	strb	r3, [r7, #17]
		L_u8DataDigit1 = APARES_AsciToHex (ARG_Pu8Data[4]);
 80035fe:	687b      	ldr	r3, [r7, #4]
 8003600:	3304      	adds	r3, #4
 8003602:	781b      	ldrb	r3, [r3, #0]
 8003604:	b2db      	uxtb	r3, r3
 8003606:	4618      	mov	r0, r3
 8003608:	f7ff ffb2 	bl	8003570 <APARES_AsciToHex>
 800360c:	4603      	mov	r3, r0
 800360e:	743b      	strb	r3, [r7, #16]
		L_u8DataDigit2 = APARES_AsciToHex (ARG_Pu8Data[5]);
 8003610:	687b      	ldr	r3, [r7, #4]
 8003612:	3305      	adds	r3, #5
 8003614:	781b      	ldrb	r3, [r3, #0]
 8003616:	b2db      	uxtb	r3, r3
 8003618:	4618      	mov	r0, r3
 800361a:	f7ff ffa9 	bl	8003570 <APARES_AsciToHex>
 800361e:	4603      	mov	r3, r0
 8003620:	73fb      	strb	r3, [r7, #15]
		L_u8DataDigit3 = APARES_AsciToHex (ARG_Pu8Data[6]);
 8003622:	687b      	ldr	r3, [r7, #4]
 8003624:	3306      	adds	r3, #6
 8003626:	781b      	ldrb	r3, [r3, #0]
 8003628:	b2db      	uxtb	r3, r3
 800362a:	4618      	mov	r0, r3
 800362c:	f7ff ffa0 	bl	8003570 <APARES_AsciToHex>
 8003630:	4603      	mov	r3, r0
 8003632:	73bb      	strb	r3, [r7, #14]

		/* Clear Low Part of Address */
		APARES_u8Address = APARES_u8Address & 0xFFFF0000;
 8003634:	4b3e      	ldr	r3, [pc, #248]	; (8003730 <APARES_voidData+0x190>)
 8003636:	681b      	ldr	r3, [r3, #0]
 8003638:	0c1b      	lsrs	r3, r3, #16
 800363a:	041b      	lsls	r3, r3, #16
 800363c:	4a3c      	ldr	r2, [pc, #240]	; (8003730 <APARES_voidData+0x190>)
 800363e:	6013      	str	r3, [r2, #0]
		APARES_u8Address = APARES_u8Address | (L_u8DataDigit3) | (L_u8DataDigit2 << 4) | (L_u8DataDigit1 << 8) | (L_u8DataDigit0<<12);
 8003640:	7bba      	ldrb	r2, [r7, #14]
 8003642:	4b3b      	ldr	r3, [pc, #236]	; (8003730 <APARES_voidData+0x190>)
 8003644:	681b      	ldr	r3, [r3, #0]
 8003646:	4313      	orrs	r3, r2
 8003648:	7bfa      	ldrb	r2, [r7, #15]
 800364a:	0112      	lsls	r2, r2, #4
 800364c:	4313      	orrs	r3, r2
 800364e:	7c3a      	ldrb	r2, [r7, #16]
 8003650:	0212      	lsls	r2, r2, #8
 8003652:	4313      	orrs	r3, r2
 8003654:	7c7a      	ldrb	r2, [r7, #17]
 8003656:	0312      	lsls	r2, r2, #12
 8003658:	4313      	orrs	r3, r2
 800365a:	4a35      	ldr	r2, [pc, #212]	; (8003730 <APARES_voidData+0x190>)
 800365c:	6013      	str	r3, [r2, #0]

		for (L_u8I=0;L_u8I<(L_u8CC/2); L_u8I++)
 800365e:	2300      	movs	r3, #0
 8003660:	75bb      	strb	r3, [r7, #22]
 8003662:	e04b      	b.n	80036fc <APARES_voidData+0x15c>
		{
			L_u8DataDigit0 = APARES_AsciToHex (ARG_Pu8Data[4*L_u8I+9 ]);
 8003664:	7dbb      	ldrb	r3, [r7, #22]
 8003666:	009b      	lsls	r3, r3, #2
 8003668:	3309      	adds	r3, #9
 800366a:	687a      	ldr	r2, [r7, #4]
 800366c:	4413      	add	r3, r2
 800366e:	781b      	ldrb	r3, [r3, #0]
 8003670:	b2db      	uxtb	r3, r3
 8003672:	4618      	mov	r0, r3
 8003674:	f7ff ff7c 	bl	8003570 <APARES_AsciToHex>
 8003678:	4603      	mov	r3, r0
 800367a:	747b      	strb	r3, [r7, #17]
			L_u8DataDigit1 = APARES_AsciToHex (ARG_Pu8Data[4*L_u8I+10]);
 800367c:	7dbb      	ldrb	r3, [r7, #22]
 800367e:	009b      	lsls	r3, r3, #2
 8003680:	330a      	adds	r3, #10
 8003682:	687a      	ldr	r2, [r7, #4]
 8003684:	4413      	add	r3, r2
 8003686:	781b      	ldrb	r3, [r3, #0]
 8003688:	b2db      	uxtb	r3, r3
 800368a:	4618      	mov	r0, r3
 800368c:	f7ff ff70 	bl	8003570 <APARES_AsciToHex>
 8003690:	4603      	mov	r3, r0
 8003692:	743b      	strb	r3, [r7, #16]
			L_u8DataDigit2 = APARES_AsciToHex (ARG_Pu8Data[4*L_u8I+11]);
 8003694:	7dbb      	ldrb	r3, [r7, #22]
 8003696:	009b      	lsls	r3, r3, #2
 8003698:	330b      	adds	r3, #11
 800369a:	687a      	ldr	r2, [r7, #4]
 800369c:	4413      	add	r3, r2
 800369e:	781b      	ldrb	r3, [r3, #0]
 80036a0:	b2db      	uxtb	r3, r3
 80036a2:	4618      	mov	r0, r3
 80036a4:	f7ff ff64 	bl	8003570 <APARES_AsciToHex>
 80036a8:	4603      	mov	r3, r0
 80036aa:	73fb      	strb	r3, [r7, #15]
			L_u8DataDigit3 = APARES_AsciToHex (ARG_Pu8Data[4*L_u8I+12]);
 80036ac:	7dbb      	ldrb	r3, [r7, #22]
 80036ae:	009b      	lsls	r3, r3, #2
 80036b0:	330c      	adds	r3, #12
 80036b2:	687a      	ldr	r2, [r7, #4]
 80036b4:	4413      	add	r3, r2
 80036b6:	781b      	ldrb	r3, [r3, #0]
 80036b8:	b2db      	uxtb	r3, r3
 80036ba:	4618      	mov	r0, r3
 80036bc:	f7ff ff58 	bl	8003570 <APARES_AsciToHex>
 80036c0:	4603      	mov	r3, r0
 80036c2:	73bb      	strb	r3, [r7, #14]

			APARES_arru16Data[L_u8DataCounter] = (L_u8DataDigit3 << 8) | (L_u8DataDigit2 << 12) | (L_u8DataDigit1) | (L_u8DataDigit0<<4);
 80036c4:	7bbb      	ldrb	r3, [r7, #14]
 80036c6:	021b      	lsls	r3, r3, #8
 80036c8:	b21a      	sxth	r2, r3
 80036ca:	7bfb      	ldrb	r3, [r7, #15]
 80036cc:	031b      	lsls	r3, r3, #12
 80036ce:	b21b      	sxth	r3, r3
 80036d0:	4313      	orrs	r3, r2
 80036d2:	b21a      	sxth	r2, r3
 80036d4:	7c3b      	ldrb	r3, [r7, #16]
 80036d6:	b21b      	sxth	r3, r3
 80036d8:	4313      	orrs	r3, r2
 80036da:	b21a      	sxth	r2, r3
 80036dc:	7c7b      	ldrb	r3, [r7, #17]
 80036de:	011b      	lsls	r3, r3, #4
 80036e0:	b21b      	sxth	r3, r3
 80036e2:	4313      	orrs	r3, r2
 80036e4:	b21a      	sxth	r2, r3
 80036e6:	7d7b      	ldrb	r3, [r7, #21]
 80036e8:	b291      	uxth	r1, r2
 80036ea:	4a12      	ldr	r2, [pc, #72]	; (8003734 <APARES_voidData+0x194>)
 80036ec:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			L_u8DataCounter++;
 80036f0:	7d7b      	ldrb	r3, [r7, #21]
 80036f2:	3301      	adds	r3, #1
 80036f4:	757b      	strb	r3, [r7, #21]
		for (L_u8I=0;L_u8I<(L_u8CC/2); L_u8I++)
 80036f6:	7dbb      	ldrb	r3, [r7, #22]
 80036f8:	3301      	adds	r3, #1
 80036fa:	75bb      	strb	r3, [r7, #22]
 80036fc:	7cbb      	ldrb	r3, [r7, #18]
 80036fe:	085b      	lsrs	r3, r3, #1
 8003700:	b2db      	uxtb	r3, r3
 8003702:	7dba      	ldrb	r2, [r7, #22]
 8003704:	429a      	cmp	r2, r3
 8003706:	d3ad      	bcc.n	8003664 <APARES_voidData+0xc4>
		}

		L_stderrorError=MFLASH_voidWriteSection(APARES_u8Address,APARES_arru16Data,(L_u8CC/2));
 8003708:	4b09      	ldr	r3, [pc, #36]	; (8003730 <APARES_voidData+0x190>)
 800370a:	6818      	ldr	r0, [r3, #0]
 800370c:	7cbb      	ldrb	r3, [r7, #18]
 800370e:	085b      	lsrs	r3, r3, #1
 8003710:	b2db      	uxtb	r3, r3
 8003712:	461a      	mov	r2, r3
 8003714:	4907      	ldr	r1, [pc, #28]	; (8003734 <APARES_voidData+0x194>)
 8003716:	f000 f90b 	bl	8003930 <MFLASH_voidWriteSection>
 800371a:	4603      	mov	r3, r0
 800371c:	75fb      	strb	r3, [r7, #23]
 800371e:	e001      	b.n	8003724 <APARES_voidData+0x184>
	}
	else
	{
		L_stderrorError=E_NULL_POINTER;
 8003720:	2302      	movs	r3, #2
 8003722:	75fb      	strb	r3, [r7, #23]
	}
	return L_stderrorError;
 8003724:	7dfb      	ldrb	r3, [r7, #23]
}
 8003726:	4618      	mov	r0, r3
 8003728:	3718      	adds	r7, #24
 800372a:	46bd      	mov	sp, r7
 800372c:	bd80      	pop	{r7, pc}
 800372e:	bf00      	nop
 8003730:	20000000 	.word	0x20000000
 8003734:	20000028 	.word	0x20000028

08003738 <APARES_voidRecord>:

void APARES_voidRecord
(
	volatile u8* ARG_Pu8Data
)
{
 8003738:	b580      	push	{r7, lr}
 800373a:	b082      	sub	sp, #8
 800373c:	af00      	add	r7, sp, #0
 800373e:	6078      	str	r0, [r7, #4]
	switch (ARG_Pu8Data[8])
 8003740:	687b      	ldr	r3, [r7, #4]
 8003742:	3308      	adds	r3, #8
 8003744:	781b      	ldrb	r3, [r3, #0]
 8003746:	b2db      	uxtb	r3, r3
 8003748:	2b34      	cmp	r3, #52	; 0x34
 800374a:	d00e      	beq.n	800376a <APARES_voidRecord+0x32>
 800374c:	2b34      	cmp	r3, #52	; 0x34
 800374e:	dc0e      	bgt.n	800376e <APARES_voidRecord+0x36>
 8003750:	2b30      	cmp	r3, #48	; 0x30
 8003752:	d002      	beq.n	800375a <APARES_voidRecord+0x22>
 8003754:	2b31      	cmp	r3, #49	; 0x31
 8003756:	d004      	beq.n	8003762 <APARES_voidRecord+0x2a>
	{
		case '0':	APARES_voidData(ARG_Pu8Data); break;
		case '4':	break;
		case '1':	APARES_u8EndMSG=1; break;
		default :	break;
 8003758:	e009      	b.n	800376e <APARES_voidRecord+0x36>
		case '0':	APARES_voidData(ARG_Pu8Data); break;
 800375a:	6878      	ldr	r0, [r7, #4]
 800375c:	f7ff ff20 	bl	80035a0 <APARES_voidData>
 8003760:	e006      	b.n	8003770 <APARES_voidRecord+0x38>
		case '1':	APARES_u8EndMSG=1; break;
 8003762:	4b05      	ldr	r3, [pc, #20]	; (8003778 <APARES_voidRecord+0x40>)
 8003764:	2201      	movs	r2, #1
 8003766:	701a      	strb	r2, [r3, #0]
 8003768:	e002      	b.n	8003770 <APARES_voidRecord+0x38>
		case '4':	break;
 800376a:	bf00      	nop
 800376c:	e000      	b.n	8003770 <APARES_voidRecord+0x38>
		default :	break;
 800376e:	bf00      	nop
	}
}
 8003770:	bf00      	nop
 8003772:	3708      	adds	r7, #8
 8003774:	46bd      	mov	sp, r7
 8003776:	bd80      	pop	{r7, pc}
 8003778:	20000024 	.word	0x20000024

0800377c <APARES_u8EndRecordFlag>:

u8 APARES_u8EndRecordFlag
(
	void
)
{
 800377c:	b480      	push	{r7}
 800377e:	b083      	sub	sp, #12
 8003780:	af00      	add	r7, sp, #0
	u8 L_u8temp =APARES_u8EndMSG;
 8003782:	4b07      	ldr	r3, [pc, #28]	; (80037a0 <APARES_u8EndRecordFlag+0x24>)
 8003784:	781b      	ldrb	r3, [r3, #0]
 8003786:	71fb      	strb	r3, [r7, #7]

	if(L_u8temp==1)
 8003788:	79fb      	ldrb	r3, [r7, #7]
 800378a:	2b01      	cmp	r3, #1
 800378c:	d102      	bne.n	8003794 <APARES_u8EndRecordFlag+0x18>
	{
		APARES_u8EndMSG=0;
 800378e:	4b04      	ldr	r3, [pc, #16]	; (80037a0 <APARES_u8EndRecordFlag+0x24>)
 8003790:	2200      	movs	r2, #0
 8003792:	701a      	strb	r2, [r3, #0]
	}
	else
	{

	}
	return L_u8temp;
 8003794:	79fb      	ldrb	r3, [r7, #7]
}
 8003796:	4618      	mov	r0, r3
 8003798:	370c      	adds	r7, #12
 800379a:	46bd      	mov	sp, r7
 800379c:	bc80      	pop	{r7}
 800379e:	4770      	bx	lr
 80037a0:	20000024 	.word	0x20000024

080037a4 <MFLASH_stderrorUnlock>:

static STD_error_t MFLASH_stderrorUnlock
(
	void
)
{
 80037a4:	b480      	push	{r7}
 80037a6:	b083      	sub	sp, #12
 80037a8:	af00      	add	r7, sp, #0
	STD_error_t L_stderrorError=E_NOK;
 80037aa:	2300      	movs	r3, #0
 80037ac:	71fb      	strb	r3, [r7, #7]
	
	if((1&(FLASH_CR>>LOCK))==1)
 80037ae:	4b0c      	ldr	r3, [pc, #48]	; (80037e0 <MFLASH_stderrorUnlock+0x3c>)
 80037b0:	681b      	ldr	r3, [r3, #0]
 80037b2:	09db      	lsrs	r3, r3, #7
 80037b4:	f003 0301 	and.w	r3, r3, #1
 80037b8:	2b01      	cmp	r3, #1
 80037ba:	d108      	bne.n	80037ce <MFLASH_stderrorUnlock+0x2a>
	{
		FLASH_KEYR=FLASH_KEY1;
 80037bc:	4b09      	ldr	r3, [pc, #36]	; (80037e4 <MFLASH_stderrorUnlock+0x40>)
 80037be:	4a0a      	ldr	r2, [pc, #40]	; (80037e8 <MFLASH_stderrorUnlock+0x44>)
 80037c0:	601a      	str	r2, [r3, #0]
		FLASH_KEYR=FLASH_KEY2;	
 80037c2:	4b08      	ldr	r3, [pc, #32]	; (80037e4 <MFLASH_stderrorUnlock+0x40>)
 80037c4:	4a09      	ldr	r2, [pc, #36]	; (80037ec <MFLASH_stderrorUnlock+0x48>)
 80037c6:	601a      	str	r2, [r3, #0]
		L_stderrorError=E_NOK;
 80037c8:	2300      	movs	r3, #0
 80037ca:	71fb      	strb	r3, [r7, #7]
 80037cc:	e001      	b.n	80037d2 <MFLASH_stderrorUnlock+0x2e>
	}
	else
	{
		L_stderrorError=E_OK;
 80037ce:	2301      	movs	r3, #1
 80037d0:	71fb      	strb	r3, [r7, #7]
	}
	
	return L_stderrorError;
 80037d2:	79fb      	ldrb	r3, [r7, #7]
}
 80037d4:	4618      	mov	r0, r3
 80037d6:	370c      	adds	r7, #12
 80037d8:	46bd      	mov	sp, r7
 80037da:	bc80      	pop	{r7}
 80037dc:	4770      	bx	lr
 80037de:	bf00      	nop
 80037e0:	40022010 	.word	0x40022010
 80037e4:	40022004 	.word	0x40022004
 80037e8:	45670123 	.word	0x45670123
 80037ec:	cdef89ab 	.word	0xcdef89ab

080037f0 <MFLASH_stderrorlock>:

static void MFLASH_stderrorlock
(
	void
)
{
 80037f0:	b480      	push	{r7}
 80037f2:	af00      	add	r7, sp, #0
	FLASH_CR|=(1<<LOCK);
 80037f4:	4b04      	ldr	r3, [pc, #16]	; (8003808 <MFLASH_stderrorlock+0x18>)
 80037f6:	681b      	ldr	r3, [r3, #0]
 80037f8:	4a03      	ldr	r2, [pc, #12]	; (8003808 <MFLASH_stderrorlock+0x18>)
 80037fa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80037fe:	6013      	str	r3, [r2, #0]
}
 8003800:	bf00      	nop
 8003802:	46bd      	mov	sp, r7
 8003804:	bc80      	pop	{r7}
 8003806:	4770      	bx	lr
 8003808:	40022010 	.word	0x40022010

0800380c <MFLASH_voidErasePage>:

void MFLASH_voidErasePage
(
	u8 ARG_u8PageNumber
)
{
 800380c:	b580      	push	{r7, lr}
 800380e:	b082      	sub	sp, #8
 8003810:	af00      	add	r7, sp, #0
 8003812:	4603      	mov	r3, r0
 8003814:	71fb      	strb	r3, [r7, #7]
	
	/*delay until no operation in Flash*/
	while((1&(FLASH_SR>>BSY))==1);
 8003816:	bf00      	nop
 8003818:	4b1e      	ldr	r3, [pc, #120]	; (8003894 <MFLASH_voidErasePage+0x88>)
 800381a:	681b      	ldr	r3, [r3, #0]
 800381c:	f003 0301 	and.w	r3, r3, #1
 8003820:	2b01      	cmp	r3, #1
 8003822:	d0f9      	beq.n	8003818 <MFLASH_voidErasePage+0xc>
	
	/*unlock Flash*/
	while((MFLASH_stderrorUnlock())!=E_OK);
 8003824:	bf00      	nop
 8003826:	f7ff ffbd 	bl	80037a4 <MFLASH_stderrorUnlock>
 800382a:	4603      	mov	r3, r0
 800382c:	2b01      	cmp	r3, #1
 800382e:	d1fa      	bne.n	8003826 <MFLASH_voidErasePage+0x1a>
	
	/*Clear pending bit*/
	FLASH_SR|=(1<<EOP);
 8003830:	4b18      	ldr	r3, [pc, #96]	; (8003894 <MFLASH_voidErasePage+0x88>)
 8003832:	681b      	ldr	r3, [r3, #0]
 8003834:	4a17      	ldr	r2, [pc, #92]	; (8003894 <MFLASH_voidErasePage+0x88>)
 8003836:	f043 0320 	orr.w	r3, r3, #32
 800383a:	6013      	str	r3, [r2, #0]
	
	/*Page erase enable*/
	FLASH_CR|=(1<<PER);
 800383c:	4b16      	ldr	r3, [pc, #88]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 800383e:	681b      	ldr	r3, [r3, #0]
 8003840:	4a15      	ldr	r2, [pc, #84]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 8003842:	f043 0302 	orr.w	r3, r3, #2
 8003846:	6013      	str	r3, [r2, #0]
	
	/*select page 1kb = 1024*/
	FLASH_AR = (u32)(ARG_u8PageNumber * 1024) + 0x08000000 ;
 8003848:	79fb      	ldrb	r3, [r7, #7]
 800384a:	029b      	lsls	r3, r3, #10
 800384c:	4a13      	ldr	r2, [pc, #76]	; (800389c <MFLASH_voidErasePage+0x90>)
 800384e:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8003852:	6013      	str	r3, [r2, #0]
	
	/*start erase*/
	FLASH_CR|=(1<<STRT);
 8003854:	4b10      	ldr	r3, [pc, #64]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 8003856:	681b      	ldr	r3, [r3, #0]
 8003858:	4a0f      	ldr	r2, [pc, #60]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 800385a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800385e:	6013      	str	r3, [r2, #0]
	
	/*delay until no operation in Flash*/
	while((1&(FLASH_SR>>BSY))==1);
 8003860:	bf00      	nop
 8003862:	4b0c      	ldr	r3, [pc, #48]	; (8003894 <MFLASH_voidErasePage+0x88>)
 8003864:	681b      	ldr	r3, [r3, #0]
 8003866:	f003 0301 	and.w	r3, r3, #1
 800386a:	2b01      	cmp	r3, #1
 800386c:	d0f9      	beq.n	8003862 <MFLASH_voidErasePage+0x56>
	
	/*Clear pending bit*/
	FLASH_SR|=(1<<EOP);
 800386e:	4b09      	ldr	r3, [pc, #36]	; (8003894 <MFLASH_voidErasePage+0x88>)
 8003870:	681b      	ldr	r3, [r3, #0]
 8003872:	4a08      	ldr	r2, [pc, #32]	; (8003894 <MFLASH_voidErasePage+0x88>)
 8003874:	f043 0320 	orr.w	r3, r3, #32
 8003878:	6013      	str	r3, [r2, #0]
	
	/*Page erase disable*/
	FLASH_CR&=~(1<<PER);
 800387a:	4b07      	ldr	r3, [pc, #28]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 800387c:	681b      	ldr	r3, [r3, #0]
 800387e:	4a06      	ldr	r2, [pc, #24]	; (8003898 <MFLASH_voidErasePage+0x8c>)
 8003880:	f023 0302 	bic.w	r3, r3, #2
 8003884:	6013      	str	r3, [r2, #0]
	
	/*lock Flash*/
	MFLASH_stderrorlock();
 8003886:	f7ff ffb3 	bl	80037f0 <MFLASH_stderrorlock>
}
 800388a:	bf00      	nop
 800388c:	3708      	adds	r7, #8
 800388e:	46bd      	mov	sp, r7
 8003890:	bd80      	pop	{r7, pc}
 8003892:	bf00      	nop
 8003894:	4002200c 	.word	0x4002200c
 8003898:	40022010 	.word	0x40022010
 800389c:	40022014 	.word	0x40022014

080038a0 <MFLASH_stderrorWrite32BitData>:
STD_error_t MFLASH_stderrorWrite32BitData
(
	u8 ARG_u8PageNumber,
	u32* ARG_Pu16Data
)
{
 80038a0:	b580      	push	{r7, lr}
 80038a2:	b084      	sub	sp, #16
 80038a4:	af00      	add	r7, sp, #0
 80038a6:	4603      	mov	r3, r0
 80038a8:	6039      	str	r1, [r7, #0]
 80038aa:	71fb      	strb	r3, [r7, #7]
	
	STD_error_t L_stderrorError=E_NOK;
 80038ac:	2300      	movs	r3, #0
 80038ae:	73fb      	strb	r3, [r7, #15]
	
	if(ARG_Pu16Data != NULL_POINTER )
 80038b0:	683b      	ldr	r3, [r7, #0]
 80038b2:	2b00      	cmp	r3, #0
 80038b4:	d031      	beq.n	800391a <MFLASH_stderrorWrite32BitData+0x7a>
	{
		
		u32 L_u32Address =(u32)(ARG_u8PageNumber * 1024) + 0x08000000 ;
 80038b6:	79fb      	ldrb	r3, [r7, #7]
 80038b8:	029b      	lsls	r3, r3, #10
 80038ba:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80038be:	60bb      	str	r3, [r7, #8]
		
		/*Page erase*/
		MFLASH_voidErasePage(ARG_u8PageNumber);
 80038c0:	79fb      	ldrb	r3, [r7, #7]
 80038c2:	4618      	mov	r0, r3
 80038c4:	f7ff ffa2 	bl	800380c <MFLASH_voidErasePage>
	
		/*unlock Flash*/
		while((MFLASH_stderrorUnlock())!=E_OK);
 80038c8:	bf00      	nop
 80038ca:	f7ff ff6b 	bl	80037a4 <MFLASH_stderrorUnlock>
 80038ce:	4603      	mov	r3, r0
 80038d0:	2b01      	cmp	r3, #1
 80038d2:	d1fa      	bne.n	80038ca <MFLASH_stderrorWrite32BitData+0x2a>
	
		/*enable Flash programming*/
		FLASH_CR|=(1<<PG);
 80038d4:	4b14      	ldr	r3, [pc, #80]	; (8003928 <MFLASH_stderrorWrite32BitData+0x88>)
 80038d6:	681b      	ldr	r3, [r3, #0]
 80038d8:	4a13      	ldr	r2, [pc, #76]	; (8003928 <MFLASH_stderrorWrite32BitData+0x88>)
 80038da:	f043 0301 	orr.w	r3, r3, #1
 80038de:	6013      	str	r3, [r2, #0]
		
		/*set data to page*/
		*((volatile u16*)L_u32Address) =*ARG_Pu16Data ;
 80038e0:	683b      	ldr	r3, [r7, #0]
 80038e2:	681a      	ldr	r2, [r3, #0]
 80038e4:	68bb      	ldr	r3, [r7, #8]
 80038e6:	b292      	uxth	r2, r2
 80038e8:	801a      	strh	r2, [r3, #0]

		/*delay until no operation in Flash*/
		while((1&(FLASH_SR>>BSY))==1);
 80038ea:	bf00      	nop
 80038ec:	4b0f      	ldr	r3, [pc, #60]	; (800392c <MFLASH_stderrorWrite32BitData+0x8c>)
 80038ee:	681b      	ldr	r3, [r3, #0]
 80038f0:	f003 0301 	and.w	r3, r3, #1
 80038f4:	2b01      	cmp	r3, #1
 80038f6:	d0f9      	beq.n	80038ec <MFLASH_stderrorWrite32BitData+0x4c>
		
		/*Clear pending bit*/
		FLASH_SR|=(1<<EOP);
 80038f8:	4b0c      	ldr	r3, [pc, #48]	; (800392c <MFLASH_stderrorWrite32BitData+0x8c>)
 80038fa:	681b      	ldr	r3, [r3, #0]
 80038fc:	4a0b      	ldr	r2, [pc, #44]	; (800392c <MFLASH_stderrorWrite32BitData+0x8c>)
 80038fe:	f043 0320 	orr.w	r3, r3, #32
 8003902:	6013      	str	r3, [r2, #0]
		
		/*disable Flash programming*/
		FLASH_CR&=~(1<<PG);
 8003904:	4b08      	ldr	r3, [pc, #32]	; (8003928 <MFLASH_stderrorWrite32BitData+0x88>)
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	4a07      	ldr	r2, [pc, #28]	; (8003928 <MFLASH_stderrorWrite32BitData+0x88>)
 800390a:	f023 0301 	bic.w	r3, r3, #1
 800390e:	6013      	str	r3, [r2, #0]
		
		/*lock Flash*/
		MFLASH_stderrorlock();
 8003910:	f7ff ff6e 	bl	80037f0 <MFLASH_stderrorlock>
		
		L_stderrorError=E_OK;
 8003914:	2301      	movs	r3, #1
 8003916:	73fb      	strb	r3, [r7, #15]
 8003918:	e001      	b.n	800391e <MFLASH_stderrorWrite32BitData+0x7e>
	}
	else
	{
		L_stderrorError=E_NULL_POINTER;
 800391a:	2302      	movs	r3, #2
 800391c:	73fb      	strb	r3, [r7, #15]
	}
	return L_stderrorError;
 800391e:	7bfb      	ldrb	r3, [r7, #15]
}
 8003920:	4618      	mov	r0, r3
 8003922:	3710      	adds	r7, #16
 8003924:	46bd      	mov	sp, r7
 8003926:	bd80      	pop	{r7, pc}
 8003928:	40022010 	.word	0x40022010
 800392c:	4002200c 	.word	0x4002200c

08003930 <MFLASH_voidWriteSection>:
(
	u32 ARG_u32Address,
	u16* ARG_Pu16Data,
	u8 ARG_u8Length
)
{
 8003930:	b580      	push	{r7, lr}
 8003932:	b086      	sub	sp, #24
 8003934:	af00      	add	r7, sp, #0
 8003936:	60f8      	str	r0, [r7, #12]
 8003938:	60b9      	str	r1, [r7, #8]
 800393a:	4613      	mov	r3, r2
 800393c:	71fb      	strb	r3, [r7, #7]
	
	STD_error_t L_stderrorError=E_NOK;
 800393e:	2300      	movs	r3, #0
 8003940:	75fb      	strb	r3, [r7, #23]
	
	if(ARG_Pu16Data != NULL_POINTER )
 8003942:	68bb      	ldr	r3, [r7, #8]
 8003944:	2b00      	cmp	r3, #0
 8003946:	d03b      	beq.n	80039c0 <MFLASH_voidWriteSection+0x90>
	{
		u8 L_u8i=0;
 8003948:	2300      	movs	r3, #0
 800394a:	75bb      	strb	r3, [r7, #22]
		
		/*Disable all interrupts to avoid errors*/
		__asm volatile ("cpsid i" : : : "memory");
 800394c:	b672      	cpsid	i

		/*unlock Flash*/
		while((MFLASH_stderrorUnlock())!=E_OK);
 800394e:	bf00      	nop
 8003950:	f7ff ff28 	bl	80037a4 <MFLASH_stderrorUnlock>
 8003954:	4603      	mov	r3, r0
 8003956:	2b01      	cmp	r3, #1
 8003958:	d1fa      	bne.n	8003950 <MFLASH_voidWriteSection+0x20>
	
		for (L_u8i = 0; L_u8i < ARG_u8Length; L_u8i++)
 800395a:	2300      	movs	r3, #0
 800395c:	75bb      	strb	r3, [r7, #22]
 800395e:	e025      	b.n	80039ac <MFLASH_voidWriteSection+0x7c>
		{
			/*enable Flash programming*/
			FLASH_CR|=(1<<PG);
 8003960:	4b1b      	ldr	r3, [pc, #108]	; (80039d0 <MFLASH_voidWriteSection+0xa0>)
 8003962:	681b      	ldr	r3, [r3, #0]
 8003964:	4a1a      	ldr	r2, [pc, #104]	; (80039d0 <MFLASH_voidWriteSection+0xa0>)
 8003966:	f043 0301 	orr.w	r3, r3, #1
 800396a:	6013      	str	r3, [r2, #0]
			
			*((volatile u16*)ARG_u32Address) = ARG_Pu16Data[L_u8i];
 800396c:	7dbb      	ldrb	r3, [r7, #22]
 800396e:	005b      	lsls	r3, r3, #1
 8003970:	68ba      	ldr	r2, [r7, #8]
 8003972:	441a      	add	r2, r3
 8003974:	68fb      	ldr	r3, [r7, #12]
 8003976:	8812      	ldrh	r2, [r2, #0]
 8003978:	801a      	strh	r2, [r3, #0]
			ARG_u32Address+=2;
 800397a:	68fb      	ldr	r3, [r7, #12]
 800397c:	3302      	adds	r3, #2
 800397e:	60fb      	str	r3, [r7, #12]
			
			/*delay until no operation in Flash*/
			while((1&(FLASH_SR>>BSY))==1);
 8003980:	bf00      	nop
 8003982:	4b14      	ldr	r3, [pc, #80]	; (80039d4 <MFLASH_voidWriteSection+0xa4>)
 8003984:	681b      	ldr	r3, [r3, #0]
 8003986:	f003 0301 	and.w	r3, r3, #1
 800398a:	2b01      	cmp	r3, #1
 800398c:	d0f9      	beq.n	8003982 <MFLASH_voidWriteSection+0x52>
			
			/*Clear pending bit*/
			FLASH_SR|=(1<<EOP);
 800398e:	4b11      	ldr	r3, [pc, #68]	; (80039d4 <MFLASH_voidWriteSection+0xa4>)
 8003990:	681b      	ldr	r3, [r3, #0]
 8003992:	4a10      	ldr	r2, [pc, #64]	; (80039d4 <MFLASH_voidWriteSection+0xa4>)
 8003994:	f043 0320 	orr.w	r3, r3, #32
 8003998:	6013      	str	r3, [r2, #0]
		
			/*disable Flash programming*/
			FLASH_CR&=~(1<<PG);
 800399a:	4b0d      	ldr	r3, [pc, #52]	; (80039d0 <MFLASH_voidWriteSection+0xa0>)
 800399c:	681b      	ldr	r3, [r3, #0]
 800399e:	4a0c      	ldr	r2, [pc, #48]	; (80039d0 <MFLASH_voidWriteSection+0xa0>)
 80039a0:	f023 0301 	bic.w	r3, r3, #1
 80039a4:	6013      	str	r3, [r2, #0]
		for (L_u8i = 0; L_u8i < ARG_u8Length; L_u8i++)
 80039a6:	7dbb      	ldrb	r3, [r7, #22]
 80039a8:	3301      	adds	r3, #1
 80039aa:	75bb      	strb	r3, [r7, #22]
 80039ac:	7dba      	ldrb	r2, [r7, #22]
 80039ae:	79fb      	ldrb	r3, [r7, #7]
 80039b0:	429a      	cmp	r2, r3
 80039b2:	d3d5      	bcc.n	8003960 <MFLASH_voidWriteSection+0x30>
		}
		
		/*Enable Interrupts again*/
		__asm volatile ("cpsie i" : : : "memory");
 80039b4:	b662      	cpsie	i

		/*lock Flash*/
		MFLASH_stderrorlock();
 80039b6:	f7ff ff1b 	bl	80037f0 <MFLASH_stderrorlock>
		
		L_stderrorError=E_OK;
 80039ba:	2301      	movs	r3, #1
 80039bc:	75fb      	strb	r3, [r7, #23]
 80039be:	e001      	b.n	80039c4 <MFLASH_voidWriteSection+0x94>
	}
	else
	{
		L_stderrorError=E_NULL_POINTER;
 80039c0:	2302      	movs	r3, #2
 80039c2:	75fb      	strb	r3, [r7, #23]
	}
	return L_stderrorError;
 80039c4:	7dfb      	ldrb	r3, [r7, #23]
}
 80039c6:	4618      	mov	r0, r3
 80039c8:	3718      	adds	r7, #24
 80039ca:	46bd      	mov	sp, r7
 80039cc:	bd80      	pop	{r7, pc}
 80039ce:	bf00      	nop
 80039d0:	40022010 	.word	0x40022010
 80039d4:	4002200c 	.word	0x4002200c

080039d8 <MFLASH_voidReadPage>:
STD_error_t MFLASH_voidReadPage
(
	u8 ARG_u8PageNumber,
	u16* ARG_Pu16Data
)
{
 80039d8:	b480      	push	{r7}
 80039da:	b085      	sub	sp, #20
 80039dc:	af00      	add	r7, sp, #0
 80039de:	4603      	mov	r3, r0
 80039e0:	6039      	str	r1, [r7, #0]
 80039e2:	71fb      	strb	r3, [r7, #7]
	STD_error_t L_stderrorError=E_NOK;
 80039e4:	2300      	movs	r3, #0
 80039e6:	73fb      	strb	r3, [r7, #15]

	if(ARG_Pu16Data != NULL_POINTER )
 80039e8:	683b      	ldr	r3, [r7, #0]
 80039ea:	2b00      	cmp	r3, #0
 80039ec:	d00c      	beq.n	8003a08 <MFLASH_voidReadPage+0x30>
	{
		u32 L_u32Address =(u32)(ARG_u8PageNumber * 1024) + 0x08000000 ;
 80039ee:	79fb      	ldrb	r3, [r7, #7]
 80039f0:	029b      	lsls	r3, r3, #10
 80039f2:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80039f6:	60bb      	str	r3, [r7, #8]

		*ARG_Pu16Data=	*((volatile u32*)L_u32Address);
 80039f8:	68bb      	ldr	r3, [r7, #8]
 80039fa:	681b      	ldr	r3, [r3, #0]
 80039fc:	b29a      	uxth	r2, r3
 80039fe:	683b      	ldr	r3, [r7, #0]
 8003a00:	801a      	strh	r2, [r3, #0]
		L_stderrorError=E_OK;
 8003a02:	2301      	movs	r3, #1
 8003a04:	73fb      	strb	r3, [r7, #15]
 8003a06:	e001      	b.n	8003a0c <MFLASH_voidReadPage+0x34>
	}
	else
	{
		L_stderrorError=E_NULL_POINTER;
 8003a08:	2302      	movs	r3, #2
 8003a0a:	73fb      	strb	r3, [r7, #15]
	}
	return L_stderrorError;
 8003a0c:	7bfb      	ldrb	r3, [r7, #15]
}
 8003a0e:	4618      	mov	r0, r3
 8003a10:	3714      	adds	r7, #20
 8003a12:	46bd      	mov	sp, r7
 8003a14:	bc80      	pop	{r7}
 8003a16:	4770      	bx	lr

08003a18 <MFLASH_voidEraseApp2Section>:

void MFLASH_voidEraseApp2Section
(
	void
)
{
 8003a18:	b580      	push	{r7, lr}
 8003a1a:	b082      	sub	sp, #8
 8003a1c:	af00      	add	r7, sp, #0
	u8 L_u8I;

	for (L_u8I=38;L_u8I<63;L_u8I++)
 8003a1e:	2326      	movs	r3, #38	; 0x26
 8003a20:	71fb      	strb	r3, [r7, #7]
 8003a22:	e006      	b.n	8003a32 <MFLASH_voidEraseApp2Section+0x1a>
	{
		MFLASH_voidErasePage(L_u8I);
 8003a24:	79fb      	ldrb	r3, [r7, #7]
 8003a26:	4618      	mov	r0, r3
 8003a28:	f7ff fef0 	bl	800380c <MFLASH_voidErasePage>
	for (L_u8I=38;L_u8I<63;L_u8I++)
 8003a2c:	79fb      	ldrb	r3, [r7, #7]
 8003a2e:	3301      	adds	r3, #1
 8003a30:	71fb      	strb	r3, [r7, #7]
 8003a32:	79fb      	ldrb	r3, [r7, #7]
 8003a34:	2b3e      	cmp	r3, #62	; 0x3e
 8003a36:	d9f5      	bls.n	8003a24 <MFLASH_voidEraseApp2Section+0xc>
	}
}
 8003a38:	bf00      	nop
 8003a3a:	bf00      	nop
 8003a3c:	3708      	adds	r7, #8
 8003a3e:	46bd      	mov	sp, r7
 8003a40:	bd80      	pop	{r7, pc}
	...

08003a44 <MGPIO_stderrorPinModeSelect>:
(
	MGPIO_Port_Name_t ARG_udtGPIOPort, 
	MGPIO_Pin_Number_t ARG_udtGPIOPin,
	MGPIO_Pin_Mode_t ARG_udtGPIOMode
)
{
 8003a44:	b480      	push	{r7}
 8003a46:	b085      	sub	sp, #20
 8003a48:	af00      	add	r7, sp, #0
 8003a4a:	4603      	mov	r3, r0
 8003a4c:	71fb      	strb	r3, [r7, #7]
 8003a4e:	460b      	mov	r3, r1
 8003a50:	71bb      	strb	r3, [r7, #6]
 8003a52:	4613      	mov	r3, r2
 8003a54:	717b      	strb	r3, [r7, #5]
	
	STD_error_t L_stderrorError=E_NOK;
 8003a56:	2300      	movs	r3, #0
 8003a58:	73fb      	strb	r3, [r7, #15]
	
	if(ARG_udtGPIOPort <= 4 && ARG_udtGPIOPin <= 15 && ARG_udtGPIOMode <= 15)
 8003a5a:	79fb      	ldrb	r3, [r7, #7]
 8003a5c:	2b04      	cmp	r3, #4
 8003a5e:	f200 812e 	bhi.w	8003cbe <MGPIO_stderrorPinModeSelect+0x27a>
 8003a62:	79bb      	ldrb	r3, [r7, #6]
 8003a64:	2b0f      	cmp	r3, #15
 8003a66:	f200 812a 	bhi.w	8003cbe <MGPIO_stderrorPinModeSelect+0x27a>
 8003a6a:	797b      	ldrb	r3, [r7, #5]
 8003a6c:	2b0f      	cmp	r3, #15
 8003a6e:	f200 8126 	bhi.w	8003cbe <MGPIO_stderrorPinModeSelect+0x27a>
	{
		
		switch(ARG_udtGPIOPort)
 8003a72:	79fb      	ldrb	r3, [r7, #7]
 8003a74:	2b04      	cmp	r3, #4
 8003a76:	f200 8120 	bhi.w	8003cba <MGPIO_stderrorPinModeSelect+0x276>
 8003a7a:	a201      	add	r2, pc, #4	; (adr r2, 8003a80 <MGPIO_stderrorPinModeSelect+0x3c>)
 8003a7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003a80:	08003a95 	.word	0x08003a95
 8003a84:	08003b03 	.word	0x08003b03
 8003a88:	08003b71 	.word	0x08003b71
 8003a8c:	08003bdf 	.word	0x08003bdf
 8003a90:	08003c4d 	.word	0x08003c4d
		{
			case GPIOA:
			{
				
				if(ARG_udtGPIOPin<=7)
 8003a94:	79bb      	ldrb	r3, [r7, #6]
 8003a96:	2b07      	cmp	r3, #7
 8003a98:	d816      	bhi.n	8003ac8 <MGPIO_stderrorPinModeSelect+0x84>
				{
					GPIOA_CRL =(GPIOA_CRL&(~(15U<<(4*ARG_udtGPIOPin))));
 8003a9a:	4b8d      	ldr	r3, [pc, #564]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003a9c:	681a      	ldr	r2, [r3, #0]
 8003a9e:	79bb      	ldrb	r3, [r7, #6]
 8003aa0:	009b      	lsls	r3, r3, #2
 8003aa2:	210f      	movs	r1, #15
 8003aa4:	fa01 f303 	lsl.w	r3, r1, r3
 8003aa8:	43db      	mvns	r3, r3
 8003aaa:	4989      	ldr	r1, [pc, #548]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003aac:	4013      	ands	r3, r2
 8003aae:	600b      	str	r3, [r1, #0]
					GPIOA_CRL|=(ARG_udtGPIOMode<<(4*ARG_udtGPIOPin));
 8003ab0:	4b87      	ldr	r3, [pc, #540]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003ab2:	681b      	ldr	r3, [r3, #0]
 8003ab4:	7979      	ldrb	r1, [r7, #5]
 8003ab6:	79ba      	ldrb	r2, [r7, #6]
 8003ab8:	0092      	lsls	r2, r2, #2
 8003aba:	fa01 f202 	lsl.w	r2, r1, r2
 8003abe:	4611      	mov	r1, r2
 8003ac0:	4a83      	ldr	r2, [pc, #524]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003ac2:	430b      	orrs	r3, r1
 8003ac4:	6013      	str	r3, [r2, #0]
 8003ac6:	e019      	b.n	8003afc <MGPIO_stderrorPinModeSelect+0xb8>
				}
				else
				{
					GPIOA_CRH =(GPIOA_CRH&(~(15U<<(4*(ARG_udtGPIOPin%8)))));
 8003ac8:	4b82      	ldr	r3, [pc, #520]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003aca:	681a      	ldr	r2, [r3, #0]
 8003acc:	79bb      	ldrb	r3, [r7, #6]
 8003ace:	f003 0307 	and.w	r3, r3, #7
 8003ad2:	009b      	lsls	r3, r3, #2
 8003ad4:	210f      	movs	r1, #15
 8003ad6:	fa01 f303 	lsl.w	r3, r1, r3
 8003ada:	43db      	mvns	r3, r3
 8003adc:	497d      	ldr	r1, [pc, #500]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003ade:	4013      	ands	r3, r2
 8003ae0:	600b      	str	r3, [r1, #0]
					GPIOA_CRH|=(ARG_udtGPIOMode<<(4*(ARG_udtGPIOPin%8)));
 8003ae2:	4b7c      	ldr	r3, [pc, #496]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003ae4:	681b      	ldr	r3, [r3, #0]
 8003ae6:	7979      	ldrb	r1, [r7, #5]
 8003ae8:	79ba      	ldrb	r2, [r7, #6]
 8003aea:	f002 0207 	and.w	r2, r2, #7
 8003aee:	0092      	lsls	r2, r2, #2
 8003af0:	fa01 f202 	lsl.w	r2, r1, r2
 8003af4:	4611      	mov	r1, r2
 8003af6:	4a77      	ldr	r2, [pc, #476]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003af8:	430b      	orrs	r3, r1
 8003afa:	6013      	str	r3, [r2, #0]
				}
				L_stderrorError=E_OK;
 8003afc:	2301      	movs	r3, #1
 8003afe:	73fb      	strb	r3, [r7, #15]
				break;
 8003b00:	e0dc      	b.n	8003cbc <MGPIO_stderrorPinModeSelect+0x278>
			}
			case GPIOB:
			{
				if(ARG_udtGPIOPin<=7)
 8003b02:	79bb      	ldrb	r3, [r7, #6]
 8003b04:	2b07      	cmp	r3, #7
 8003b06:	d816      	bhi.n	8003b36 <MGPIO_stderrorPinModeSelect+0xf2>
				{
					GPIOB_CRL =(GPIOA_CRL&(~(15U<<(4*ARG_udtGPIOPin))));
 8003b08:	4b71      	ldr	r3, [pc, #452]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b0a:	681a      	ldr	r2, [r3, #0]
 8003b0c:	79bb      	ldrb	r3, [r7, #6]
 8003b0e:	009b      	lsls	r3, r3, #2
 8003b10:	210f      	movs	r1, #15
 8003b12:	fa01 f303 	lsl.w	r3, r1, r3
 8003b16:	43db      	mvns	r3, r3
 8003b18:	496d      	ldr	r1, [pc, #436]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b1a:	4013      	ands	r3, r2
 8003b1c:	600b      	str	r3, [r1, #0]
					GPIOB_CRL|=(ARG_udtGPIOMode<<(4*ARG_udtGPIOPin));
 8003b1e:	4b6c      	ldr	r3, [pc, #432]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b20:	681b      	ldr	r3, [r3, #0]
 8003b22:	7979      	ldrb	r1, [r7, #5]
 8003b24:	79ba      	ldrb	r2, [r7, #6]
 8003b26:	0092      	lsls	r2, r2, #2
 8003b28:	fa01 f202 	lsl.w	r2, r1, r2
 8003b2c:	4611      	mov	r1, r2
 8003b2e:	4a68      	ldr	r2, [pc, #416]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b30:	430b      	orrs	r3, r1
 8003b32:	6013      	str	r3, [r2, #0]
 8003b34:	e019      	b.n	8003b6a <MGPIO_stderrorPinModeSelect+0x126>
				}
				else
				{
					GPIOB_CRH =(GPIOA_CRH&(~(15U<<(4*(ARG_udtGPIOPin%8)))));
 8003b36:	4b67      	ldr	r3, [pc, #412]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003b38:	681a      	ldr	r2, [r3, #0]
 8003b3a:	79bb      	ldrb	r3, [r7, #6]
 8003b3c:	f003 0307 	and.w	r3, r3, #7
 8003b40:	009b      	lsls	r3, r3, #2
 8003b42:	210f      	movs	r1, #15
 8003b44:	fa01 f303 	lsl.w	r3, r1, r3
 8003b48:	43db      	mvns	r3, r3
 8003b4a:	4962      	ldr	r1, [pc, #392]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003b4c:	4013      	ands	r3, r2
 8003b4e:	600b      	str	r3, [r1, #0]
					GPIOB_CRH|=(ARG_udtGPIOMode<<(4*(ARG_udtGPIOPin%8)));
 8003b50:	4b60      	ldr	r3, [pc, #384]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003b52:	681b      	ldr	r3, [r3, #0]
 8003b54:	7979      	ldrb	r1, [r7, #5]
 8003b56:	79ba      	ldrb	r2, [r7, #6]
 8003b58:	f002 0207 	and.w	r2, r2, #7
 8003b5c:	0092      	lsls	r2, r2, #2
 8003b5e:	fa01 f202 	lsl.w	r2, r1, r2
 8003b62:	4611      	mov	r1, r2
 8003b64:	4a5b      	ldr	r2, [pc, #364]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003b66:	430b      	orrs	r3, r1
 8003b68:	6013      	str	r3, [r2, #0]
				}
				L_stderrorError=E_OK;
 8003b6a:	2301      	movs	r3, #1
 8003b6c:	73fb      	strb	r3, [r7, #15]
				break;
 8003b6e:	e0a5      	b.n	8003cbc <MGPIO_stderrorPinModeSelect+0x278>
			}
			case GPIOC:
			{
				if(ARG_udtGPIOPin<=7)
 8003b70:	79bb      	ldrb	r3, [r7, #6]
 8003b72:	2b07      	cmp	r3, #7
 8003b74:	d816      	bhi.n	8003ba4 <MGPIO_stderrorPinModeSelect+0x160>
				{
					GPIOC_CRL =(GPIOA_CRL&(~(15U<<(4*ARG_udtGPIOPin))));
 8003b76:	4b56      	ldr	r3, [pc, #344]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b78:	681a      	ldr	r2, [r3, #0]
 8003b7a:	79bb      	ldrb	r3, [r7, #6]
 8003b7c:	009b      	lsls	r3, r3, #2
 8003b7e:	210f      	movs	r1, #15
 8003b80:	fa01 f303 	lsl.w	r3, r1, r3
 8003b84:	43db      	mvns	r3, r3
 8003b86:	4952      	ldr	r1, [pc, #328]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b88:	4013      	ands	r3, r2
 8003b8a:	600b      	str	r3, [r1, #0]
					GPIOC_CRL|=(ARG_udtGPIOMode<<(4*ARG_udtGPIOPin));
 8003b8c:	4b50      	ldr	r3, [pc, #320]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b8e:	681b      	ldr	r3, [r3, #0]
 8003b90:	7979      	ldrb	r1, [r7, #5]
 8003b92:	79ba      	ldrb	r2, [r7, #6]
 8003b94:	0092      	lsls	r2, r2, #2
 8003b96:	fa01 f202 	lsl.w	r2, r1, r2
 8003b9a:	4611      	mov	r1, r2
 8003b9c:	4a4c      	ldr	r2, [pc, #304]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003b9e:	430b      	orrs	r3, r1
 8003ba0:	6013      	str	r3, [r2, #0]
 8003ba2:	e019      	b.n	8003bd8 <MGPIO_stderrorPinModeSelect+0x194>
				}
				else
				{
					GPIOC_CRH =(GPIOA_CRH&(~(15U<<(4*(ARG_udtGPIOPin%8)))));
 8003ba4:	4b4b      	ldr	r3, [pc, #300]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003ba6:	681a      	ldr	r2, [r3, #0]
 8003ba8:	79bb      	ldrb	r3, [r7, #6]
 8003baa:	f003 0307 	and.w	r3, r3, #7
 8003bae:	009b      	lsls	r3, r3, #2
 8003bb0:	210f      	movs	r1, #15
 8003bb2:	fa01 f303 	lsl.w	r3, r1, r3
 8003bb6:	43db      	mvns	r3, r3
 8003bb8:	4946      	ldr	r1, [pc, #280]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003bba:	4013      	ands	r3, r2
 8003bbc:	600b      	str	r3, [r1, #0]
					GPIOC_CRH|=(ARG_udtGPIOMode<<(4*(ARG_udtGPIOPin%8)));
 8003bbe:	4b45      	ldr	r3, [pc, #276]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003bc0:	681b      	ldr	r3, [r3, #0]
 8003bc2:	7979      	ldrb	r1, [r7, #5]
 8003bc4:	79ba      	ldrb	r2, [r7, #6]
 8003bc6:	f002 0207 	and.w	r2, r2, #7
 8003bca:	0092      	lsls	r2, r2, #2
 8003bcc:	fa01 f202 	lsl.w	r2, r1, r2
 8003bd0:	4611      	mov	r1, r2
 8003bd2:	4a40      	ldr	r2, [pc, #256]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003bd4:	430b      	orrs	r3, r1
 8003bd6:	6013      	str	r3, [r2, #0]
				}
				L_stderrorError=E_OK;
 8003bd8:	2301      	movs	r3, #1
 8003bda:	73fb      	strb	r3, [r7, #15]
				break;
 8003bdc:	e06e      	b.n	8003cbc <MGPIO_stderrorPinModeSelect+0x278>
			}
			case GPIOD:
			{
				if(ARG_udtGPIOPin<=7)
 8003bde:	79bb      	ldrb	r3, [r7, #6]
 8003be0:	2b07      	cmp	r3, #7
 8003be2:	d816      	bhi.n	8003c12 <MGPIO_stderrorPinModeSelect+0x1ce>
				{
					GPIOD_CRL =(GPIOA_CRL&(~(15U<<(4*ARG_udtGPIOPin))));
 8003be4:	4b3a      	ldr	r3, [pc, #232]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003be6:	681a      	ldr	r2, [r3, #0]
 8003be8:	79bb      	ldrb	r3, [r7, #6]
 8003bea:	009b      	lsls	r3, r3, #2
 8003bec:	210f      	movs	r1, #15
 8003bee:	fa01 f303 	lsl.w	r3, r1, r3
 8003bf2:	43db      	mvns	r3, r3
 8003bf4:	4936      	ldr	r1, [pc, #216]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003bf6:	4013      	ands	r3, r2
 8003bf8:	600b      	str	r3, [r1, #0]
					GPIOD_CRL|=(ARG_udtGPIOMode<<(4*ARG_udtGPIOPin));
 8003bfa:	4b35      	ldr	r3, [pc, #212]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	7979      	ldrb	r1, [r7, #5]
 8003c00:	79ba      	ldrb	r2, [r7, #6]
 8003c02:	0092      	lsls	r2, r2, #2
 8003c04:	fa01 f202 	lsl.w	r2, r1, r2
 8003c08:	4611      	mov	r1, r2
 8003c0a:	4a31      	ldr	r2, [pc, #196]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003c0c:	430b      	orrs	r3, r1
 8003c0e:	6013      	str	r3, [r2, #0]
 8003c10:	e019      	b.n	8003c46 <MGPIO_stderrorPinModeSelect+0x202>
				}
				else
				{
					GPIOD_CRH =(GPIOA_CRH&(~(15U<<(4*(ARG_udtGPIOPin%8)))));
 8003c12:	4b30      	ldr	r3, [pc, #192]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c14:	681a      	ldr	r2, [r3, #0]
 8003c16:	79bb      	ldrb	r3, [r7, #6]
 8003c18:	f003 0307 	and.w	r3, r3, #7
 8003c1c:	009b      	lsls	r3, r3, #2
 8003c1e:	210f      	movs	r1, #15
 8003c20:	fa01 f303 	lsl.w	r3, r1, r3
 8003c24:	43db      	mvns	r3, r3
 8003c26:	492b      	ldr	r1, [pc, #172]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c28:	4013      	ands	r3, r2
 8003c2a:	600b      	str	r3, [r1, #0]
					GPIOD_CRH|=(ARG_udtGPIOMode<<(4*(ARG_udtGPIOPin%8)));
 8003c2c:	4b29      	ldr	r3, [pc, #164]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c2e:	681b      	ldr	r3, [r3, #0]
 8003c30:	7979      	ldrb	r1, [r7, #5]
 8003c32:	79ba      	ldrb	r2, [r7, #6]
 8003c34:	f002 0207 	and.w	r2, r2, #7
 8003c38:	0092      	lsls	r2, r2, #2
 8003c3a:	fa01 f202 	lsl.w	r2, r1, r2
 8003c3e:	4611      	mov	r1, r2
 8003c40:	4a24      	ldr	r2, [pc, #144]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c42:	430b      	orrs	r3, r1
 8003c44:	6013      	str	r3, [r2, #0]
				}
				L_stderrorError=E_OK;
 8003c46:	2301      	movs	r3, #1
 8003c48:	73fb      	strb	r3, [r7, #15]
				break;
 8003c4a:	e037      	b.n	8003cbc <MGPIO_stderrorPinModeSelect+0x278>
			}
			case GPIOE:
			{
				if(ARG_udtGPIOPin<=7)
 8003c4c:	79bb      	ldrb	r3, [r7, #6]
 8003c4e:	2b07      	cmp	r3, #7
 8003c50:	d816      	bhi.n	8003c80 <MGPIO_stderrorPinModeSelect+0x23c>
				{
					GPIOE_CRL =(GPIOA_CRL&(~(15U<<(4*ARG_udtGPIOPin))));
 8003c52:	4b1f      	ldr	r3, [pc, #124]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003c54:	681a      	ldr	r2, [r3, #0]
 8003c56:	79bb      	ldrb	r3, [r7, #6]
 8003c58:	009b      	lsls	r3, r3, #2
 8003c5a:	210f      	movs	r1, #15
 8003c5c:	fa01 f303 	lsl.w	r3, r1, r3
 8003c60:	43db      	mvns	r3, r3
 8003c62:	491b      	ldr	r1, [pc, #108]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003c64:	4013      	ands	r3, r2
 8003c66:	600b      	str	r3, [r1, #0]
					GPIOE_CRL|=(ARG_udtGPIOMode<<(4*ARG_udtGPIOPin));
 8003c68:	4b19      	ldr	r3, [pc, #100]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003c6a:	681b      	ldr	r3, [r3, #0]
 8003c6c:	7979      	ldrb	r1, [r7, #5]
 8003c6e:	79ba      	ldrb	r2, [r7, #6]
 8003c70:	0092      	lsls	r2, r2, #2
 8003c72:	fa01 f202 	lsl.w	r2, r1, r2
 8003c76:	4611      	mov	r1, r2
 8003c78:	4a15      	ldr	r2, [pc, #84]	; (8003cd0 <MGPIO_stderrorPinModeSelect+0x28c>)
 8003c7a:	430b      	orrs	r3, r1
 8003c7c:	6013      	str	r3, [r2, #0]
 8003c7e:	e019      	b.n	8003cb4 <MGPIO_stderrorPinModeSelect+0x270>
				}
				else
				{
					GPIOE_CRH =(GPIOA_CRH&(~(15U<<(4*(ARG_udtGPIOPin%8)))));
 8003c80:	4b14      	ldr	r3, [pc, #80]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c82:	681a      	ldr	r2, [r3, #0]
 8003c84:	79bb      	ldrb	r3, [r7, #6]
 8003c86:	f003 0307 	and.w	r3, r3, #7
 8003c8a:	009b      	lsls	r3, r3, #2
 8003c8c:	210f      	movs	r1, #15
 8003c8e:	fa01 f303 	lsl.w	r3, r1, r3
 8003c92:	43db      	mvns	r3, r3
 8003c94:	490f      	ldr	r1, [pc, #60]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c96:	4013      	ands	r3, r2
 8003c98:	600b      	str	r3, [r1, #0]
					GPIOE_CRH|=(ARG_udtGPIOMode<<(4*(ARG_udtGPIOPin%8)));
 8003c9a:	4b0e      	ldr	r3, [pc, #56]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003c9c:	681b      	ldr	r3, [r3, #0]
 8003c9e:	7979      	ldrb	r1, [r7, #5]
 8003ca0:	79ba      	ldrb	r2, [r7, #6]
 8003ca2:	f002 0207 	and.w	r2, r2, #7
 8003ca6:	0092      	lsls	r2, r2, #2
 8003ca8:	fa01 f202 	lsl.w	r2, r1, r2
 8003cac:	4611      	mov	r1, r2
 8003cae:	4a09      	ldr	r2, [pc, #36]	; (8003cd4 <MGPIO_stderrorPinModeSelect+0x290>)
 8003cb0:	430b      	orrs	r3, r1
 8003cb2:	6013      	str	r3, [r2, #0]
				}
				L_stderrorError=E_OK;
 8003cb4:	2301      	movs	r3, #1
 8003cb6:	73fb      	strb	r3, [r7, #15]
				break;
 8003cb8:	e000      	b.n	8003cbc <MGPIO_stderrorPinModeSelect+0x278>
			}
			default :
			{
				/*nothing*/
				break;
 8003cba:	bf00      	nop
		switch(ARG_udtGPIOPort)
 8003cbc:	e001      	b.n	8003cc2 <MGPIO_stderrorPinModeSelect+0x27e>
			}
		}
	}
	else
	{
		L_stderrorError=E_NOK;
 8003cbe:	2300      	movs	r3, #0
 8003cc0:	73fb      	strb	r3, [r7, #15]
	}
	
	return L_stderrorError;
 8003cc2:	7bfb      	ldrb	r3, [r7, #15]
	
}
 8003cc4:	4618      	mov	r0, r3
 8003cc6:	3714      	adds	r7, #20
 8003cc8:	46bd      	mov	sp, r7
 8003cca:	bc80      	pop	{r7}
 8003ccc:	4770      	bx	lr
 8003cce:	bf00      	nop
 8003cd0:	40010800 	.word	0x40010800
 8003cd4:	40010804 	.word	0x40010804

08003cd8 <MGPIO_stderrorSetPinValueBSSR>:
(
	MGPIO_Port_Name_t ARG_udtGPIOPort, 
	MGPIO_Pin_Number_t ARG_udtGPIOPin, 
	MGPIO_Output_State_t ARG_udtValue
)
{
 8003cd8:	b480      	push	{r7}
 8003cda:	b085      	sub	sp, #20
 8003cdc:	af00      	add	r7, sp, #0
 8003cde:	4603      	mov	r3, r0
 8003ce0:	71fb      	strb	r3, [r7, #7]
 8003ce2:	460b      	mov	r3, r1
 8003ce4:	71bb      	strb	r3, [r7, #6]
 8003ce6:	4613      	mov	r3, r2
 8003ce8:	717b      	strb	r3, [r7, #5]
	
	STD_error_t L_stderrorError=E_NOK;
 8003cea:	2300      	movs	r3, #0
 8003cec:	73fb      	strb	r3, [r7, #15]
	
	if(ARG_udtGPIOPort <= 7 && ARG_udtGPIOPin <= 15 && ARG_udtValue <= 1)
 8003cee:	79fb      	ldrb	r3, [r7, #7]
 8003cf0:	2b07      	cmp	r3, #7
 8003cf2:	f200 80b8 	bhi.w	8003e66 <MGPIO_stderrorSetPinValueBSSR+0x18e>
 8003cf6:	79bb      	ldrb	r3, [r7, #6]
 8003cf8:	2b0f      	cmp	r3, #15
 8003cfa:	f200 80b4 	bhi.w	8003e66 <MGPIO_stderrorSetPinValueBSSR+0x18e>
 8003cfe:	797b      	ldrb	r3, [r7, #5]
 8003d00:	2b01      	cmp	r3, #1
 8003d02:	f200 80b0 	bhi.w	8003e66 <MGPIO_stderrorSetPinValueBSSR+0x18e>
	{
		
		if(ARG_udtValue==LOW)
 8003d06:	797b      	ldrb	r3, [r7, #5]
 8003d08:	2b00      	cmp	r3, #0
 8003d0a:	d157      	bne.n	8003dbc <MGPIO_stderrorSetPinValueBSSR+0xe4>
		{
			
			switch(ARG_udtGPIOPort)
 8003d0c:	79fb      	ldrb	r3, [r7, #7]
 8003d0e:	2b04      	cmp	r3, #4
 8003d10:	f200 80a5 	bhi.w	8003e5e <MGPIO_stderrorSetPinValueBSSR+0x186>
 8003d14:	a201      	add	r2, pc, #4	; (adr r2, 8003d1c <MGPIO_stderrorSetPinValueBSSR+0x44>)
 8003d16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003d1a:	bf00      	nop
 8003d1c:	08003d31 	.word	0x08003d31
 8003d20:	08003d4d 	.word	0x08003d4d
 8003d24:	08003d69 	.word	0x08003d69
 8003d28:	08003d85 	.word	0x08003d85
 8003d2c:	08003da1 	.word	0x08003da1
			{
				case GPIOA:
				{
					GPIOA_BSRR |=(1<<(ARG_udtGPIOPin+BSRR_OFFSET));
 8003d30:	4b51      	ldr	r3, [pc, #324]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d32:	681b      	ldr	r3, [r3, #0]
 8003d34:	79ba      	ldrb	r2, [r7, #6]
 8003d36:	3210      	adds	r2, #16
 8003d38:	2101      	movs	r1, #1
 8003d3a:	fa01 f202 	lsl.w	r2, r1, r2
 8003d3e:	4611      	mov	r1, r2
 8003d40:	4a4d      	ldr	r2, [pc, #308]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d42:	430b      	orrs	r3, r1
 8003d44:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003d46:	2301      	movs	r3, #1
 8003d48:	73fb      	strb	r3, [r7, #15]
					break;
 8003d4a:	e08b      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOB:
				{
					GPIOB_BSRR |=(1<<(ARG_udtGPIOPin+BSRR_OFFSET));
 8003d4c:	4b4a      	ldr	r3, [pc, #296]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d4e:	681b      	ldr	r3, [r3, #0]
 8003d50:	79ba      	ldrb	r2, [r7, #6]
 8003d52:	3210      	adds	r2, #16
 8003d54:	2101      	movs	r1, #1
 8003d56:	fa01 f202 	lsl.w	r2, r1, r2
 8003d5a:	4611      	mov	r1, r2
 8003d5c:	4a46      	ldr	r2, [pc, #280]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d5e:	430b      	orrs	r3, r1
 8003d60:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003d62:	2301      	movs	r3, #1
 8003d64:	73fb      	strb	r3, [r7, #15]
					break;
 8003d66:	e07d      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOC:
				{
					GPIOC_BSRR |=(1<<(ARG_udtGPIOPin+BSRR_OFFSET));
 8003d68:	4b43      	ldr	r3, [pc, #268]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d6a:	681b      	ldr	r3, [r3, #0]
 8003d6c:	79ba      	ldrb	r2, [r7, #6]
 8003d6e:	3210      	adds	r2, #16
 8003d70:	2101      	movs	r1, #1
 8003d72:	fa01 f202 	lsl.w	r2, r1, r2
 8003d76:	4611      	mov	r1, r2
 8003d78:	4a3f      	ldr	r2, [pc, #252]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d7a:	430b      	orrs	r3, r1
 8003d7c:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003d7e:	2301      	movs	r3, #1
 8003d80:	73fb      	strb	r3, [r7, #15]
					break;
 8003d82:	e06f      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOD:
				{
					GPIOD_BSRR |=(1<<(ARG_udtGPIOPin+BSRR_OFFSET));
 8003d84:	4b3c      	ldr	r3, [pc, #240]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d86:	681b      	ldr	r3, [r3, #0]
 8003d88:	79ba      	ldrb	r2, [r7, #6]
 8003d8a:	3210      	adds	r2, #16
 8003d8c:	2101      	movs	r1, #1
 8003d8e:	fa01 f202 	lsl.w	r2, r1, r2
 8003d92:	4611      	mov	r1, r2
 8003d94:	4a38      	ldr	r2, [pc, #224]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003d96:	430b      	orrs	r3, r1
 8003d98:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003d9a:	2301      	movs	r3, #1
 8003d9c:	73fb      	strb	r3, [r7, #15]
					break;
 8003d9e:	e061      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOE:
				{
					GPIOE_BSRR |=(1<<(ARG_udtGPIOPin+BSRR_OFFSET));
 8003da0:	4b35      	ldr	r3, [pc, #212]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003da2:	681b      	ldr	r3, [r3, #0]
 8003da4:	79ba      	ldrb	r2, [r7, #6]
 8003da6:	3210      	adds	r2, #16
 8003da8:	2101      	movs	r1, #1
 8003daa:	fa01 f202 	lsl.w	r2, r1, r2
 8003dae:	4611      	mov	r1, r2
 8003db0:	4a31      	ldr	r2, [pc, #196]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003db2:	430b      	orrs	r3, r1
 8003db4:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003db6:	2301      	movs	r3, #1
 8003db8:	73fb      	strb	r3, [r7, #15]
					break;
 8003dba:	e053      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
			}
			
		}
		else
		{
			switch(ARG_udtGPIOPort)
 8003dbc:	79fb      	ldrb	r3, [r7, #7]
 8003dbe:	2b04      	cmp	r3, #4
 8003dc0:	d84f      	bhi.n	8003e62 <MGPIO_stderrorSetPinValueBSSR+0x18a>
 8003dc2:	a201      	add	r2, pc, #4	; (adr r2, 8003dc8 <MGPIO_stderrorSetPinValueBSSR+0xf0>)
 8003dc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003dc8:	08003ddd 	.word	0x08003ddd
 8003dcc:	08003df7 	.word	0x08003df7
 8003dd0:	08003e11 	.word	0x08003e11
 8003dd4:	08003e2b 	.word	0x08003e2b
 8003dd8:	08003e45 	.word	0x08003e45
			{
				case GPIOA:
				{
					GPIOA_BSRR |=(1<<(ARG_udtGPIOPin));
 8003ddc:	4b26      	ldr	r3, [pc, #152]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003dde:	681b      	ldr	r3, [r3, #0]
 8003de0:	79ba      	ldrb	r2, [r7, #6]
 8003de2:	2101      	movs	r1, #1
 8003de4:	fa01 f202 	lsl.w	r2, r1, r2
 8003de8:	4611      	mov	r1, r2
 8003dea:	4a23      	ldr	r2, [pc, #140]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003dec:	430b      	orrs	r3, r1
 8003dee:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003df0:	2301      	movs	r3, #1
 8003df2:	73fb      	strb	r3, [r7, #15]
					break;
 8003df4:	e036      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOB:
				{
					GPIOB_BSRR |=(1<<(ARG_udtGPIOPin));
 8003df6:	4b20      	ldr	r3, [pc, #128]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003df8:	681b      	ldr	r3, [r3, #0]
 8003dfa:	79ba      	ldrb	r2, [r7, #6]
 8003dfc:	2101      	movs	r1, #1
 8003dfe:	fa01 f202 	lsl.w	r2, r1, r2
 8003e02:	4611      	mov	r1, r2
 8003e04:	4a1c      	ldr	r2, [pc, #112]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e06:	430b      	orrs	r3, r1
 8003e08:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003e0a:	2301      	movs	r3, #1
 8003e0c:	73fb      	strb	r3, [r7, #15]
					break;
 8003e0e:	e029      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOC:
				{
					GPIOC_BSRR |=(1<<(ARG_udtGPIOPin));
 8003e10:	4b19      	ldr	r3, [pc, #100]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e12:	681b      	ldr	r3, [r3, #0]
 8003e14:	79ba      	ldrb	r2, [r7, #6]
 8003e16:	2101      	movs	r1, #1
 8003e18:	fa01 f202 	lsl.w	r2, r1, r2
 8003e1c:	4611      	mov	r1, r2
 8003e1e:	4a16      	ldr	r2, [pc, #88]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e20:	430b      	orrs	r3, r1
 8003e22:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003e24:	2301      	movs	r3, #1
 8003e26:	73fb      	strb	r3, [r7, #15]
					break;
 8003e28:	e01c      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOD:
				{
					GPIOD_BSRR |=(1<<(ARG_udtGPIOPin));
 8003e2a:	4b13      	ldr	r3, [pc, #76]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e2c:	681b      	ldr	r3, [r3, #0]
 8003e2e:	79ba      	ldrb	r2, [r7, #6]
 8003e30:	2101      	movs	r1, #1
 8003e32:	fa01 f202 	lsl.w	r2, r1, r2
 8003e36:	4611      	mov	r1, r2
 8003e38:	4a0f      	ldr	r2, [pc, #60]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e3a:	430b      	orrs	r3, r1
 8003e3c:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003e3e:	2301      	movs	r3, #1
 8003e40:	73fb      	strb	r3, [r7, #15]
					break;
 8003e42:	e00f      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
				}
				case GPIOE:
				{
					GPIOE_BSRR |=(1<<(ARG_udtGPIOPin));
 8003e44:	4b0c      	ldr	r3, [pc, #48]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e46:	681b      	ldr	r3, [r3, #0]
 8003e48:	79ba      	ldrb	r2, [r7, #6]
 8003e4a:	2101      	movs	r1, #1
 8003e4c:	fa01 f202 	lsl.w	r2, r1, r2
 8003e50:	4611      	mov	r1, r2
 8003e52:	4a09      	ldr	r2, [pc, #36]	; (8003e78 <MGPIO_stderrorSetPinValueBSSR+0x1a0>)
 8003e54:	430b      	orrs	r3, r1
 8003e56:	6013      	str	r3, [r2, #0]
					L_stderrorError=E_OK;
 8003e58:	2301      	movs	r3, #1
 8003e5a:	73fb      	strb	r3, [r7, #15]
					break;
 8003e5c:	e002      	b.n	8003e64 <MGPIO_stderrorSetPinValueBSSR+0x18c>
					break;
 8003e5e:	bf00      	nop
 8003e60:	e003      	b.n	8003e6a <MGPIO_stderrorSetPinValueBSSR+0x192>
				}
				default :
				{
					/*nothing*/
					break;
 8003e62:	bf00      	nop
		if(ARG_udtValue==LOW)
 8003e64:	e001      	b.n	8003e6a <MGPIO_stderrorSetPinValueBSSR+0x192>
		}
		
	}
	else
	{
		L_stderrorError=E_NOK;
 8003e66:	2300      	movs	r3, #0
 8003e68:	73fb      	strb	r3, [r7, #15]
	}
	return L_stderrorError;
 8003e6a:	7bfb      	ldrb	r3, [r7, #15]
}
 8003e6c:	4618      	mov	r0, r3
 8003e6e:	3714      	adds	r7, #20
 8003e70:	46bd      	mov	sp, r7
 8003e72:	bc80      	pop	{r7}
 8003e74:	4770      	bx	lr
 8003e76:	bf00      	nop
 8003e78:	40010810 	.word	0x40010810

08003e7c <MGPIO_stderrorSerialWireJTAGConfiguration>:

STD_error_t MGPIO_stderrorSerialWireJTAGConfiguration
(
	MGPIO_JTAG_Configuration_t ARG_udtJTAGConfiguration
)
{
 8003e7c:	b480      	push	{r7}
 8003e7e:	b085      	sub	sp, #20
 8003e80:	af00      	add	r7, sp, #0
 8003e82:	4603      	mov	r3, r0
 8003e84:	71fb      	strb	r3, [r7, #7]
	STD_error_t L_stderrorError=E_NOK;
 8003e86:	2300      	movs	r3, #0
 8003e88:	73fb      	strb	r3, [r7, #15]

	if((ARG_udtJTAGConfiguration<=2)||(ARG_udtJTAGConfiguration==4))
 8003e8a:	79fb      	ldrb	r3, [r7, #7]
 8003e8c:	2b02      	cmp	r3, #2
 8003e8e:	d902      	bls.n	8003e96 <MGPIO_stderrorSerialWireJTAGConfiguration+0x1a>
 8003e90:	79fb      	ldrb	r3, [r7, #7]
 8003e92:	2b04      	cmp	r3, #4
 8003e94:	d110      	bne.n	8003eb8 <MGPIO_stderrorSerialWireJTAGConfiguration+0x3c>
	{
		/*Serial wire JTAG configuration*/
		AFIO_MAPR&=(~(SWJ_CFG_FLAG<<SWJ_CFG));
 8003e96:	4b0c      	ldr	r3, [pc, #48]	; (8003ec8 <MGPIO_stderrorSerialWireJTAGConfiguration+0x4c>)
 8003e98:	681b      	ldr	r3, [r3, #0]
 8003e9a:	4a0b      	ldr	r2, [pc, #44]	; (8003ec8 <MGPIO_stderrorSerialWireJTAGConfiguration+0x4c>)
 8003e9c:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8003ea0:	6013      	str	r3, [r2, #0]
		AFIO_MAPR|=(ARG_udtJTAGConfiguration<<SWJ_CFG);
 8003ea2:	4b09      	ldr	r3, [pc, #36]	; (8003ec8 <MGPIO_stderrorSerialWireJTAGConfiguration+0x4c>)
 8003ea4:	681b      	ldr	r3, [r3, #0]
 8003ea6:	79fa      	ldrb	r2, [r7, #7]
 8003ea8:	0612      	lsls	r2, r2, #24
 8003eaa:	4611      	mov	r1, r2
 8003eac:	4a06      	ldr	r2, [pc, #24]	; (8003ec8 <MGPIO_stderrorSerialWireJTAGConfiguration+0x4c>)
 8003eae:	430b      	orrs	r3, r1
 8003eb0:	6013      	str	r3, [r2, #0]

		L_stderrorError=E_OK;
 8003eb2:	2301      	movs	r3, #1
 8003eb4:	73fb      	strb	r3, [r7, #15]
 8003eb6:	e001      	b.n	8003ebc <MGPIO_stderrorSerialWireJTAGConfiguration+0x40>

	}
	else
	{

		L_stderrorError=E_NOK;
 8003eb8:	2300      	movs	r3, #0
 8003eba:	73fb      	strb	r3, [r7, #15]

	}

	return L_stderrorError;
 8003ebc:	7bfb      	ldrb	r3, [r7, #15]

}
 8003ebe:	4618      	mov	r0, r3
 8003ec0:	3714      	adds	r7, #20
 8003ec2:	46bd      	mov	sp, r7
 8003ec4:	bc80      	pop	{r7}
 8003ec6:	4770      	bx	lr
 8003ec8:	40010004 	.word	0x40010004

08003ecc <MNVIC_stderrorEnableIRQ>:

STD_error_t MNVIC_stderrorEnableIRQ
(
	IRQ_t ARG_udtIRQn
)
{
 8003ecc:	b480      	push	{r7}
 8003ece:	b085      	sub	sp, #20
 8003ed0:	af00      	add	r7, sp, #0
 8003ed2:	4603      	mov	r3, r0
 8003ed4:	71fb      	strb	r3, [r7, #7]
	STD_error_t L_stderrorError=E_NOK;
 8003ed6:	2300      	movs	r3, #0
 8003ed8:	73fb      	strb	r3, [r7, #15]
	
	if(ARG_udtIRQn<=59)
 8003eda:	79fb      	ldrb	r3, [r7, #7]
 8003edc:	2b3b      	cmp	r3, #59	; 0x3b
 8003ede:	d80e      	bhi.n	8003efe <MNVIC_stderrorEnableIRQ+0x32>
	{
		MNVIC->ISER[ARG_udtIRQn/32]= (1<<(ARG_udtIRQn%32));
 8003ee0:	79fb      	ldrb	r3, [r7, #7]
 8003ee2:	f003 031f 	and.w	r3, r3, #31
 8003ee6:	2201      	movs	r2, #1
 8003ee8:	fa02 f103 	lsl.w	r1, r2, r3
 8003eec:	4a08      	ldr	r2, [pc, #32]	; (8003f10 <MNVIC_stderrorEnableIRQ+0x44>)
 8003eee:	79fb      	ldrb	r3, [r7, #7]
 8003ef0:	095b      	lsrs	r3, r3, #5
 8003ef2:	b2db      	uxtb	r3, r3
 8003ef4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		L_stderrorError=E_OK;
 8003ef8:	2301      	movs	r3, #1
 8003efa:	73fb      	strb	r3, [r7, #15]
 8003efc:	e001      	b.n	8003f02 <MNVIC_stderrorEnableIRQ+0x36>
	}
	else
	{
		L_stderrorError=E_NOK;
 8003efe:	2300      	movs	r3, #0
 8003f00:	73fb      	strb	r3, [r7, #15]
	}
	return L_stderrorError;
 8003f02:	7bfb      	ldrb	r3, [r7, #15]
}
 8003f04:	4618      	mov	r0, r3
 8003f06:	3714      	adds	r7, #20
 8003f08:	46bd      	mov	sp, r7
 8003f0a:	bc80      	pop	{r7}
 8003f0c:	4770      	bx	lr
 8003f0e:	bf00      	nop
 8003f10:	e000e100 	.word	0xe000e100

08003f14 <NVIC_voidResetRequest>:

void NVIC_voidResetRequest
(
	void
)
{
 8003f14:	b480      	push	{r7}
 8003f16:	af00      	add	r7, sp, #0
	/*check if all memory write of previous instruction has finished */
	__asm volatile ("dsb 0xF":::"memory");
 8003f18:	f3bf 8f4f 	dsb	sy

	/*set key & keep PRIGROUP & System reset request*/
	MSCB->AIRCR =(MSCB_VECTKEY<<16)|((7<<8)&MSCB->AIRCR )|(1<<2);
 8003f1c:	4b06      	ldr	r3, [pc, #24]	; (8003f38 <NVIC_voidResetRequest+0x24>)
 8003f1e:	f8d3 3688 	ldr.w	r3, [r3, #1672]	; 0x688
 8003f22:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8003f26:	4904      	ldr	r1, [pc, #16]	; (8003f38 <NVIC_voidResetRequest+0x24>)
 8003f28:	4b04      	ldr	r3, [pc, #16]	; (8003f3c <NVIC_voidResetRequest+0x28>)
 8003f2a:	4313      	orrs	r3, r2
 8003f2c:	f8c1 3688 	str.w	r3, [r1, #1672]	; 0x688

	/*check if all memory write of previous instruction has finished */
	__asm volatile ("dsb 0xF":::"memory");
 8003f30:	f3bf 8f4f 	dsb	sy

	/* wait until reset */
	for(;;)
	{
		__asm volatile ("nop");
 8003f34:	bf00      	nop
 8003f36:	e7fd      	b.n	8003f34 <NVIC_voidResetRequest+0x20>
 8003f38:	e000e008 	.word	0xe000e008
 8003f3c:	05fa0004 	.word	0x05fa0004

08003f40 <MRCC_stderrorInit>:
	RCC_ClkSrc_t 		ARG_udtClkSrc ,
	RCC_AHBPreScaler_t 	ARG_udtAHBPreScaler,
	RCC_APBPreScaler_t 	ARG_udtAPB1PreScaler,
	RCC_APBPreScaler_t 	ARG_udtAPB2PreScaler
)
{
 8003f40:	b490      	push	{r4, r7}
 8003f42:	b084      	sub	sp, #16
 8003f44:	af00      	add	r7, sp, #0
 8003f46:	4604      	mov	r4, r0
 8003f48:	4608      	mov	r0, r1
 8003f4a:	4611      	mov	r1, r2
 8003f4c:	461a      	mov	r2, r3
 8003f4e:	4623      	mov	r3, r4
 8003f50:	71fb      	strb	r3, [r7, #7]
 8003f52:	4603      	mov	r3, r0
 8003f54:	71bb      	strb	r3, [r7, #6]
 8003f56:	460b      	mov	r3, r1
 8003f58:	717b      	strb	r3, [r7, #5]
 8003f5a:	4613      	mov	r3, r2
 8003f5c:	713b      	strb	r3, [r7, #4]
	STD_error_t L_stderrorError=E_NOK;
 8003f5e:	2300      	movs	r3, #0
 8003f60:	73fb      	strb	r3, [r7, #15]
	
	if((ARG_udtClkSrc<=4)&&(((ARG_udtAHBPreScaler>=8)&&(ARG_udtAHBPreScaler<=15))||(ARG_udtAHBPreScaler==0))&&(((ARG_udtAPB1PreScaler>=3)&&(ARG_udtAPB1PreScaler<=7))||(ARG_udtAPB1PreScaler==0))&&(((ARG_udtAPB2PreScaler>=3)&&(ARG_udtAPB2PreScaler<=7))||(ARG_udtAPB2PreScaler==0)))
 8003f62:	79fb      	ldrb	r3, [r7, #7]
 8003f64:	2b04      	cmp	r3, #4
 8003f66:	f200 8137 	bhi.w	80041d8 <MRCC_stderrorInit+0x298>
 8003f6a:	79bb      	ldrb	r3, [r7, #6]
 8003f6c:	2b07      	cmp	r3, #7
 8003f6e:	d902      	bls.n	8003f76 <MRCC_stderrorInit+0x36>
 8003f70:	79bb      	ldrb	r3, [r7, #6]
 8003f72:	2b0f      	cmp	r3, #15
 8003f74:	d903      	bls.n	8003f7e <MRCC_stderrorInit+0x3e>
 8003f76:	79bb      	ldrb	r3, [r7, #6]
 8003f78:	2b00      	cmp	r3, #0
 8003f7a:	f040 812d 	bne.w	80041d8 <MRCC_stderrorInit+0x298>
 8003f7e:	797b      	ldrb	r3, [r7, #5]
 8003f80:	2b02      	cmp	r3, #2
 8003f82:	d902      	bls.n	8003f8a <MRCC_stderrorInit+0x4a>
 8003f84:	797b      	ldrb	r3, [r7, #5]
 8003f86:	2b07      	cmp	r3, #7
 8003f88:	d903      	bls.n	8003f92 <MRCC_stderrorInit+0x52>
 8003f8a:	797b      	ldrb	r3, [r7, #5]
 8003f8c:	2b00      	cmp	r3, #0
 8003f8e:	f040 8123 	bne.w	80041d8 <MRCC_stderrorInit+0x298>
 8003f92:	793b      	ldrb	r3, [r7, #4]
 8003f94:	2b02      	cmp	r3, #2
 8003f96:	d902      	bls.n	8003f9e <MRCC_stderrorInit+0x5e>
 8003f98:	793b      	ldrb	r3, [r7, #4]
 8003f9a:	2b07      	cmp	r3, #7
 8003f9c:	d903      	bls.n	8003fa6 <MRCC_stderrorInit+0x66>
 8003f9e:	793b      	ldrb	r3, [r7, #4]
 8003fa0:	2b00      	cmp	r3, #0
 8003fa2:	f040 8119 	bne.w	80041d8 <MRCC_stderrorInit+0x298>
	{
		switch(ARG_udtClkSrc)
 8003fa6:	79fb      	ldrb	r3, [r7, #7]
 8003fa8:	2b05      	cmp	r3, #5
 8003faa:	f200 80e7 	bhi.w	800417c <MRCC_stderrorInit+0x23c>
 8003fae:	a201      	add	r2, pc, #4	; (adr r2, 8003fb4 <MRCC_stderrorInit+0x74>)
 8003fb0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003fb4:	08003fcd 	.word	0x08003fcd
 8003fb8:	08004013 	.word	0x08004013
 8003fbc:	08004059 	.word	0x08004059
 8003fc0:	08004087 	.word	0x08004087
 8003fc4:	080040dd 	.word	0x080040dd
 8003fc8:	08004133 	.word	0x08004133
		{
			case HSE_Crystal:
			{
				MRCC_u8PllCk=0;
 8003fcc:	4b86      	ldr	r3, [pc, #536]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 8003fce:	2200      	movs	r2, #0
 8003fd0:	701a      	strb	r2, [r3, #0]
				/*SYSCLK equal to HSE*/
				RCC_CFGR=(RCC_CFGR&(~(3U<<SW)));
 8003fd2:	4b86      	ldr	r3, [pc, #536]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8003fd4:	681b      	ldr	r3, [r3, #0]
 8003fd6:	4a85      	ldr	r2, [pc, #532]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8003fd8:	f023 0303 	bic.w	r3, r3, #3
 8003fdc:	6013      	str	r3, [r2, #0]
				RCC_CFGR|=(HSE_FLAG);
 8003fde:	4b83      	ldr	r3, [pc, #524]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8003fe0:	681b      	ldr	r3, [r3, #0]
 8003fe2:	4a82      	ldr	r2, [pc, #520]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8003fe4:	f043 0301 	orr.w	r3, r3, #1
 8003fe8:	6013      	str	r3, [r2, #0]
				/*Disable bypass*/
				RCC_CR	&=~(1U<<HSEBYP);
 8003fea:	4b81      	ldr	r3, [pc, #516]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8003fec:	681b      	ldr	r3, [r3, #0]
 8003fee:	4a80      	ldr	r2, [pc, #512]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8003ff0:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003ff4:	6013      	str	r3, [r2, #0]
				/*Enable HSE*/
				RCC_CR|=(1U<<HSEON);
 8003ff6:	4b7e      	ldr	r3, [pc, #504]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8003ff8:	681b      	ldr	r3, [r3, #0]
 8003ffa:	4a7d      	ldr	r2, [pc, #500]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8003ffc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004000:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSERDY)&1))==0);
 8004002:	bf00      	nop
 8004004:	4b7a      	ldr	r3, [pc, #488]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004006:	681b      	ldr	r3, [r3, #0]
 8004008:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800400c:	2b00      	cmp	r3, #0
 800400e:	d0f9      	beq.n	8004004 <MRCC_stderrorInit+0xc4>
				break;
 8004010:	e0b5      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			case HSE_RC:
			{
				MRCC_u8PllCk=0;
 8004012:	4b75      	ldr	r3, [pc, #468]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 8004014:	2200      	movs	r2, #0
 8004016:	701a      	strb	r2, [r3, #0]
				/*SYSCLK equal to HSE*/
				RCC_CFGR=(RCC_CFGR&(~(3U<<SW)));
 8004018:	4b74      	ldr	r3, [pc, #464]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800401a:	681b      	ldr	r3, [r3, #0]
 800401c:	4a73      	ldr	r2, [pc, #460]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800401e:	f023 0303 	bic.w	r3, r3, #3
 8004022:	6013      	str	r3, [r2, #0]
				RCC_CFGR|=(HSE_FLAG);
 8004024:	4b71      	ldr	r3, [pc, #452]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004026:	681b      	ldr	r3, [r3, #0]
 8004028:	4a70      	ldr	r2, [pc, #448]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800402a:	f043 0301 	orr.w	r3, r3, #1
 800402e:	6013      	str	r3, [r2, #0]
				/*Enable bypass*/
				RCC_CR|=(1U<<HSEBYP);
 8004030:	4b6f      	ldr	r3, [pc, #444]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004032:	681b      	ldr	r3, [r3, #0]
 8004034:	4a6e      	ldr	r2, [pc, #440]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004036:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800403a:	6013      	str	r3, [r2, #0]
				/*Enable HSE*/
				RCC_CR|=(1U<<HSEON);
 800403c:	4b6c      	ldr	r3, [pc, #432]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	4a6b      	ldr	r2, [pc, #428]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004042:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004046:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSERDY)&1))==0);
 8004048:	bf00      	nop
 800404a:	4b69      	ldr	r3, [pc, #420]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800404c:	681b      	ldr	r3, [r3, #0]
 800404e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004052:	2b00      	cmp	r3, #0
 8004054:	d0f9      	beq.n	800404a <MRCC_stderrorInit+0x10a>
				break;
 8004056:	e092      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			case HSI:
			{
				MRCC_u8PllCk=0;
 8004058:	4b63      	ldr	r3, [pc, #396]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 800405a:	2200      	movs	r2, #0
 800405c:	701a      	strb	r2, [r3, #0]
				/*SYSCLK equal to HSI*/
				RCC_CFGR=(RCC_CFGR&(~(3U<<SW)));
 800405e:	4b63      	ldr	r3, [pc, #396]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004060:	681b      	ldr	r3, [r3, #0]
 8004062:	4a62      	ldr	r2, [pc, #392]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004064:	f023 0303 	bic.w	r3, r3, #3
 8004068:	6013      	str	r3, [r2, #0]
				/*Enable HSI*/
				RCC_CR|=(1U<<HSION);
 800406a:	4b61      	ldr	r3, [pc, #388]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800406c:	681b      	ldr	r3, [r3, #0]
 800406e:	4a60      	ldr	r2, [pc, #384]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004070:	f043 0301 	orr.w	r3, r3, #1
 8004074:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSIRDY)&1))==0);
 8004076:	bf00      	nop
 8004078:	4b5d      	ldr	r3, [pc, #372]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800407a:	681b      	ldr	r3, [r3, #0]
 800407c:	f003 0302 	and.w	r3, r3, #2
 8004080:	2b00      	cmp	r3, #0
 8004082:	d0f9      	beq.n	8004078 <MRCC_stderrorInit+0x138>
				
				
				break;
 8004084:	e07b      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			case PLL_HSE:
			{
				MRCC_u8PllCk=1;
 8004086:	4b58      	ldr	r3, [pc, #352]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 8004088:	2201      	movs	r2, #1
 800408a:	701a      	strb	r2, [r3, #0]
				/*Disable PLL*/
				RCC_CR &=(~(1<<PLLRON));
 800408c:	4b58      	ldr	r3, [pc, #352]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800408e:	681b      	ldr	r3, [r3, #0]
 8004090:	4a57      	ldr	r2, [pc, #348]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004092:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004096:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>PLLRDY)&1))==1);
 8004098:	bf00      	nop
 800409a:	4b55      	ldr	r3, [pc, #340]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800409c:	681b      	ldr	r3, [r3, #0]
 800409e:	0e5b      	lsrs	r3, r3, #25
 80040a0:	f003 0301 	and.w	r3, r3, #1
 80040a4:	2b01      	cmp	r3, #1
 80040a6:	d0f8      	beq.n	800409a <MRCC_stderrorInit+0x15a>
				/*Enable HSE*/
				RCC_CR|=(1U<<HSEON);
 80040a8:	4b51      	ldr	r3, [pc, #324]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040aa:	681b      	ldr	r3, [r3, #0]
 80040ac:	4a50      	ldr	r2, [pc, #320]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80040b2:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSERDY)&1))==0);
 80040b4:	bf00      	nop
 80040b6:	4b4e      	ldr	r3, [pc, #312]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040b8:	681b      	ldr	r3, [r3, #0]
 80040ba:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80040be:	2b00      	cmp	r3, #0
 80040c0:	d0f9      	beq.n	80040b6 <MRCC_stderrorInit+0x176>
				/*PLL HSE SELECT*/
				RCC_CFGR|=(1U<<PLLSRC);
 80040c2:	4b4a      	ldr	r3, [pc, #296]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80040c4:	681b      	ldr	r3, [r3, #0]
 80040c6:	4a49      	ldr	r2, [pc, #292]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80040c8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80040cc:	6013      	str	r3, [r2, #0]
				/*PLL NO DIVIDED HSE */
				RCC_CFGR&=(~(1<<PLLXTPRE));
 80040ce:	4b47      	ldr	r3, [pc, #284]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80040d0:	681b      	ldr	r3, [r3, #0]
 80040d2:	4a46      	ldr	r2, [pc, #280]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80040d4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80040d8:	6013      	str	r3, [r2, #0]
				break;
 80040da:	e050      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			case PLL_HSE_DIVIDED_BY_2:
			{
				MRCC_u8PllCk=1;
 80040dc:	4b42      	ldr	r3, [pc, #264]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 80040de:	2201      	movs	r2, #1
 80040e0:	701a      	strb	r2, [r3, #0]
				/*Disable PLL*/
				RCC_CR &=(~(1<<PLLRON));
 80040e2:	4b43      	ldr	r3, [pc, #268]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040e4:	681b      	ldr	r3, [r3, #0]
 80040e6:	4a42      	ldr	r2, [pc, #264]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040e8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80040ec:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>PLLRDY)&1))==1);
 80040ee:	bf00      	nop
 80040f0:	4b3f      	ldr	r3, [pc, #252]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 80040f2:	681b      	ldr	r3, [r3, #0]
 80040f4:	0e5b      	lsrs	r3, r3, #25
 80040f6:	f003 0301 	and.w	r3, r3, #1
 80040fa:	2b01      	cmp	r3, #1
 80040fc:	d0f8      	beq.n	80040f0 <MRCC_stderrorInit+0x1b0>
				/*Enable HSE*/
				RCC_CR|=(1U<<HSEON);
 80040fe:	4b3c      	ldr	r3, [pc, #240]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004100:	681b      	ldr	r3, [r3, #0]
 8004102:	4a3b      	ldr	r2, [pc, #236]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004104:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004108:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSERDY)&1))==0);
 800410a:	bf00      	nop
 800410c:	4b38      	ldr	r3, [pc, #224]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800410e:	681b      	ldr	r3, [r3, #0]
 8004110:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004114:	2b00      	cmp	r3, #0
 8004116:	d0f9      	beq.n	800410c <MRCC_stderrorInit+0x1cc>
				/*PLL HSE SELECT*/
				RCC_CFGR|=(1U<<PLLSRC);
 8004118:	4b34      	ldr	r3, [pc, #208]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800411a:	681b      	ldr	r3, [r3, #0]
 800411c:	4a33      	ldr	r2, [pc, #204]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800411e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004122:	6013      	str	r3, [r2, #0]
				/*PLL NO DIVIDED HSE */
				RCC_CFGR|=(1U<<PLLXTPRE);
 8004124:	4b31      	ldr	r3, [pc, #196]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004126:	681b      	ldr	r3, [r3, #0]
 8004128:	4a30      	ldr	r2, [pc, #192]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800412a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800412e:	6013      	str	r3, [r2, #0]
				break;
 8004130:	e025      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			case PLL_HSI_DIVIDED_BY_2:
			{
				MRCC_u8PllCk=1;
 8004132:	4b2d      	ldr	r3, [pc, #180]	; (80041e8 <MRCC_stderrorInit+0x2a8>)
 8004134:	2201      	movs	r2, #1
 8004136:	701a      	strb	r2, [r3, #0]
				/*Disable PLL*/
				RCC_CR &=(~(1<<PLLRON));
 8004138:	4b2d      	ldr	r3, [pc, #180]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800413a:	681b      	ldr	r3, [r3, #0]
 800413c:	4a2c      	ldr	r2, [pc, #176]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800413e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004142:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>PLLRDY)&1))==1);
 8004144:	bf00      	nop
 8004146:	4b2a      	ldr	r3, [pc, #168]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004148:	681b      	ldr	r3, [r3, #0]
 800414a:	0e5b      	lsrs	r3, r3, #25
 800414c:	f003 0301 	and.w	r3, r3, #1
 8004150:	2b01      	cmp	r3, #1
 8004152:	d0f8      	beq.n	8004146 <MRCC_stderrorInit+0x206>
				/*Enable HSI*/
				RCC_CR|=(1U<<HSION);
 8004154:	4b26      	ldr	r3, [pc, #152]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004156:	681b      	ldr	r3, [r3, #0]
 8004158:	4a25      	ldr	r2, [pc, #148]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 800415a:	f043 0301 	orr.w	r3, r3, #1
 800415e:	6013      	str	r3, [r2, #0]
				while((((RCC_CR>>HSIRDY)&1))==0);
 8004160:	bf00      	nop
 8004162:	4b23      	ldr	r3, [pc, #140]	; (80041f0 <MRCC_stderrorInit+0x2b0>)
 8004164:	681b      	ldr	r3, [r3, #0]
 8004166:	f003 0302 	and.w	r3, r3, #2
 800416a:	2b00      	cmp	r3, #0
 800416c:	d0f9      	beq.n	8004162 <MRCC_stderrorInit+0x222>
				/*PLL HSI SELECT*/
				RCC_CFGR&=~(1U<<PLLSRC);
 800416e:	4b1f      	ldr	r3, [pc, #124]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004170:	681b      	ldr	r3, [r3, #0]
 8004172:	4a1e      	ldr	r2, [pc, #120]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004174:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004178:	6013      	str	r3, [r2, #0]
				break;
 800417a:	e000      	b.n	800417e <MRCC_stderrorInit+0x23e>
			}
			default : 
			{
				/*nothing*/
				break;
 800417c:	bf00      	nop
			}
		}
		
		/*AHB1*/
		RCC_CFGR=(RCC_CFGR&AHB_FLAG);
 800417e:	4b1b      	ldr	r3, [pc, #108]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004180:	681b      	ldr	r3, [r3, #0]
 8004182:	4a1a      	ldr	r2, [pc, #104]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004184:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8004188:	6013      	str	r3, [r2, #0]
		RCC_CFGR|=(ARG_udtAHBPreScaler<<HPRE);
 800418a:	4b18      	ldr	r3, [pc, #96]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800418c:	681b      	ldr	r3, [r3, #0]
 800418e:	79ba      	ldrb	r2, [r7, #6]
 8004190:	0112      	lsls	r2, r2, #4
 8004192:	4611      	mov	r1, r2
 8004194:	4a15      	ldr	r2, [pc, #84]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 8004196:	430b      	orrs	r3, r1
 8004198:	6013      	str	r3, [r2, #0]
		/*APB1*/
		RCC_CFGR=(RCC_CFGR&APB1_FLAG);
 800419a:	4b14      	ldr	r3, [pc, #80]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 800419c:	681b      	ldr	r3, [r3, #0]
 800419e:	4a13      	ldr	r2, [pc, #76]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041a0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80041a4:	6013      	str	r3, [r2, #0]
		RCC_CFGR|=(ARG_udtAPB1PreScaler<<PPRE1);
 80041a6:	4b11      	ldr	r3, [pc, #68]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041a8:	681b      	ldr	r3, [r3, #0]
 80041aa:	797a      	ldrb	r2, [r7, #5]
 80041ac:	0212      	lsls	r2, r2, #8
 80041ae:	4611      	mov	r1, r2
 80041b0:	4a0e      	ldr	r2, [pc, #56]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041b2:	430b      	orrs	r3, r1
 80041b4:	6013      	str	r3, [r2, #0]
		/*APB2*/
		RCC_CFGR=(RCC_CFGR&APB2_FLAG);
 80041b6:	4b0d      	ldr	r3, [pc, #52]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041b8:	681b      	ldr	r3, [r3, #0]
 80041ba:	4a0c      	ldr	r2, [pc, #48]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041bc:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80041c0:	6013      	str	r3, [r2, #0]
		RCC_CFGR|=(ARG_udtAPB2PreScaler<<PPRE2);
 80041c2:	4b0a      	ldr	r3, [pc, #40]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041c4:	681b      	ldr	r3, [r3, #0]
 80041c6:	793a      	ldrb	r2, [r7, #4]
 80041c8:	02d2      	lsls	r2, r2, #11
 80041ca:	4611      	mov	r1, r2
 80041cc:	4a07      	ldr	r2, [pc, #28]	; (80041ec <MRCC_stderrorInit+0x2ac>)
 80041ce:	430b      	orrs	r3, r1
 80041d0:	6013      	str	r3, [r2, #0]
		
		L_stderrorError = E_OK;
 80041d2:	2301      	movs	r3, #1
 80041d4:	73fb      	strb	r3, [r7, #15]
 80041d6:	e001      	b.n	80041dc <MRCC_stderrorInit+0x29c>
	}
	else
	{
		L_stderrorError=E_NOK;
 80041d8:	2300      	movs	r3, #0
 80041da:	73fb      	strb	r3, [r7, #15]
	}
	
	return L_stderrorError;
 80041dc:	7bfb      	ldrb	r3, [r7, #15]
}
 80041de:	4618      	mov	r0, r3
 80041e0:	3710      	adds	r7, #16
 80041e2:	46bd      	mov	sp, r7
 80041e4:	bc90      	pop	{r4, r7}
 80041e6:	4770      	bx	lr
 80041e8:	200000f0 	.word	0x200000f0
 80041ec:	40021004 	.word	0x40021004
 80041f0:	40021000 	.word	0x40021000

080041f4 <RCC_EnablePeripheralClk>:
STD_error_t RCC_EnablePeripheralClk
(
	RCC_Bus_t 			ARG_udtBus,
	RCC_PeripheraName_t ARG_udtPeripheraName
)
{
 80041f4:	b480      	push	{r7}
 80041f6:	b085      	sub	sp, #20
 80041f8:	af00      	add	r7, sp, #0
 80041fa:	4603      	mov	r3, r0
 80041fc:	460a      	mov	r2, r1
 80041fe:	71fb      	strb	r3, [r7, #7]
 8004200:	4613      	mov	r3, r2
 8004202:	71bb      	strb	r3, [r7, #6]
	
	STD_error_t L_stderrorError=E_NOK;
 8004204:	2300      	movs	r3, #0
 8004206:	73fb      	strb	r3, [r7, #15]
	
	switch(ARG_udtBus)
 8004208:	79fb      	ldrb	r3, [r7, #7]
 800420a:	2b02      	cmp	r3, #2
 800420c:	d01e      	beq.n	800424c <RCC_EnablePeripheralClk+0x58>
 800420e:	2b02      	cmp	r3, #2
 8004210:	dc28      	bgt.n	8004264 <RCC_EnablePeripheralClk+0x70>
 8004212:	2b00      	cmp	r3, #0
 8004214:	d002      	beq.n	800421c <RCC_EnablePeripheralClk+0x28>
 8004216:	2b01      	cmp	r3, #1
 8004218:	d00c      	beq.n	8004234 <RCC_EnablePeripheralClk+0x40>
 800421a:	e023      	b.n	8004264 <RCC_EnablePeripheralClk+0x70>
	{
		case AHB1:
		{
			RCC_AHBENR|=(1U<<ARG_udtPeripheraName);
 800421c:	4b16      	ldr	r3, [pc, #88]	; (8004278 <RCC_EnablePeripheralClk+0x84>)
 800421e:	681a      	ldr	r2, [r3, #0]
 8004220:	79bb      	ldrb	r3, [r7, #6]
 8004222:	2101      	movs	r1, #1
 8004224:	fa01 f303 	lsl.w	r3, r1, r3
 8004228:	4913      	ldr	r1, [pc, #76]	; (8004278 <RCC_EnablePeripheralClk+0x84>)
 800422a:	4313      	orrs	r3, r2
 800422c:	600b      	str	r3, [r1, #0]
			L_stderrorError=E_OK;
 800422e:	2301      	movs	r3, #1
 8004230:	73fb      	strb	r3, [r7, #15]
			break;
 8004232:	e01a      	b.n	800426a <RCC_EnablePeripheralClk+0x76>
		}
		case APB1:
		{
			RCC_APB1ENR|=(1U<<ARG_udtPeripheraName);
 8004234:	4b11      	ldr	r3, [pc, #68]	; (800427c <RCC_EnablePeripheralClk+0x88>)
 8004236:	681a      	ldr	r2, [r3, #0]
 8004238:	79bb      	ldrb	r3, [r7, #6]
 800423a:	2101      	movs	r1, #1
 800423c:	fa01 f303 	lsl.w	r3, r1, r3
 8004240:	490e      	ldr	r1, [pc, #56]	; (800427c <RCC_EnablePeripheralClk+0x88>)
 8004242:	4313      	orrs	r3, r2
 8004244:	600b      	str	r3, [r1, #0]
			L_stderrorError=E_OK;
 8004246:	2301      	movs	r3, #1
 8004248:	73fb      	strb	r3, [r7, #15]
			break;
 800424a:	e00e      	b.n	800426a <RCC_EnablePeripheralClk+0x76>
		}
		case APB2:
		{
			RCC_APB2ENR|=(1U<<ARG_udtPeripheraName);
 800424c:	4b0c      	ldr	r3, [pc, #48]	; (8004280 <RCC_EnablePeripheralClk+0x8c>)
 800424e:	681a      	ldr	r2, [r3, #0]
 8004250:	79bb      	ldrb	r3, [r7, #6]
 8004252:	2101      	movs	r1, #1
 8004254:	fa01 f303 	lsl.w	r3, r1, r3
 8004258:	4909      	ldr	r1, [pc, #36]	; (8004280 <RCC_EnablePeripheralClk+0x8c>)
 800425a:	4313      	orrs	r3, r2
 800425c:	600b      	str	r3, [r1, #0]
			L_stderrorError=E_OK;
 800425e:	2301      	movs	r3, #1
 8004260:	73fb      	strb	r3, [r7, #15]
			break;
 8004262:	e002      	b.n	800426a <RCC_EnablePeripheralClk+0x76>
		}
		
		default:
		{
			L_stderrorError=E_NOK;
 8004264:	2300      	movs	r3, #0
 8004266:	73fb      	strb	r3, [r7, #15]
			break;
 8004268:	bf00      	nop
		}
			
	}
	return L_stderrorError;
 800426a:	7bfb      	ldrb	r3, [r7, #15]
	
}
 800426c:	4618      	mov	r0, r3
 800426e:	3714      	adds	r7, #20
 8004270:	46bd      	mov	sp, r7
 8004272:	bc80      	pop	{r7}
 8004274:	4770      	bx	lr
 8004276:	bf00      	nop
 8004278:	40021014 	.word	0x40021014
 800427c:	4002101c 	.word	0x4002101c
 8004280:	40021018 	.word	0x40021018

08004284 <MSYSTICK_stderrorInit>:

STD_error_t MSYSTICK_stderrorInit
(
	MSYSTICK_CLkSRC_t ARG_udtCLkSRC
)
{
 8004284:	b480      	push	{r7}
 8004286:	b085      	sub	sp, #20
 8004288:	af00      	add	r7, sp, #0
 800428a:	4603      	mov	r3, r0
 800428c:	71fb      	strb	r3, [r7, #7]
	STD_error_t L_stderrorError=E_NOK;
 800428e:	2300      	movs	r3, #0
 8004290:	73fb      	strb	r3, [r7, #15]
	
	if(ARG_udtCLkSRC <=1)
 8004292:	79fb      	ldrb	r3, [r7, #7]
 8004294:	2b01      	cmp	r3, #1
 8004296:	d810      	bhi.n	80042ba <MSYSTICK_stderrorInit+0x36>
	{
		/*Disable SysTick peripheral and SysTick interrupt*/
		STK_CTRL =(STK_CTRL&(~STK_CTRL_Flag));
 8004298:	4b0c      	ldr	r3, [pc, #48]	; (80042cc <MSYSTICK_stderrorInit+0x48>)
 800429a:	681b      	ldr	r3, [r3, #0]
 800429c:	4a0b      	ldr	r2, [pc, #44]	; (80042cc <MSYSTICK_stderrorInit+0x48>)
 800429e:	f023 0307 	bic.w	r3, r3, #7
 80042a2:	6013      	str	r3, [r2, #0]
		/*Select Clock Source*/
		STK_CTRL|=(ARG_udtCLkSRC<<2);
 80042a4:	4b09      	ldr	r3, [pc, #36]	; (80042cc <MSYSTICK_stderrorInit+0x48>)
 80042a6:	681b      	ldr	r3, [r3, #0]
 80042a8:	79fa      	ldrb	r2, [r7, #7]
 80042aa:	0092      	lsls	r2, r2, #2
 80042ac:	4611      	mov	r1, r2
 80042ae:	4a07      	ldr	r2, [pc, #28]	; (80042cc <MSYSTICK_stderrorInit+0x48>)
 80042b0:	430b      	orrs	r3, r1
 80042b2:	6013      	str	r3, [r2, #0]
		L_stderrorError=E_OK;
 80042b4:	2301      	movs	r3, #1
 80042b6:	73fb      	strb	r3, [r7, #15]
 80042b8:	e001      	b.n	80042be <MSYSTICK_stderrorInit+0x3a>
		
	}
	else
	{
		L_stderrorError=E_NOK;
 80042ba:	2300      	movs	r3, #0
 80042bc:	73fb      	strb	r3, [r7, #15]
	}
	
	return L_stderrorError;
 80042be:	7bfb      	ldrb	r3, [r7, #15]
}
 80042c0:	4618      	mov	r0, r3
 80042c2:	3714      	adds	r7, #20
 80042c4:	46bd      	mov	sp, r7
 80042c6:	bc80      	pop	{r7}
 80042c8:	4770      	bx	lr
 80042ca:	bf00      	nop
 80042cc:	e000e010 	.word	0xe000e010

080042d0 <MSYSTICK_stderrorSetBusyWait>:

STD_error_t MSYSTICK_stderrorSetBusyWait
(
	u32 ARG_u32Ticks
)
{
 80042d0:	b480      	push	{r7}
 80042d2:	b085      	sub	sp, #20
 80042d4:	af00      	add	r7, sp, #0
 80042d6:	6078      	str	r0, [r7, #4]
	STD_error_t L_stderrorError=E_NOK;
 80042d8:	2300      	movs	r3, #0
 80042da:	73fb      	strb	r3, [r7, #15]
	STK_LOAD =ARG_u32Ticks-1;
 80042dc:	4a0e      	ldr	r2, [pc, #56]	; (8004318 <MSYSTICK_stderrorSetBusyWait+0x48>)
 80042de:	687b      	ldr	r3, [r7, #4]
 80042e0:	3b01      	subs	r3, #1
 80042e2:	6013      	str	r3, [r2, #0]
	STK_VAL=0;
 80042e4:	4b0d      	ldr	r3, [pc, #52]	; (800431c <MSYSTICK_stderrorSetBusyWait+0x4c>)
 80042e6:	2200      	movs	r2, #0
 80042e8:	601a      	str	r2, [r3, #0]
	STK_CTRL |=1U;
 80042ea:	4b0d      	ldr	r3, [pc, #52]	; (8004320 <MSYSTICK_stderrorSetBusyWait+0x50>)
 80042ec:	681b      	ldr	r3, [r3, #0]
 80042ee:	4a0c      	ldr	r2, [pc, #48]	; (8004320 <MSYSTICK_stderrorSetBusyWait+0x50>)
 80042f0:	f043 0301 	orr.w	r3, r3, #1
 80042f4:	6013      	str	r3, [r2, #0]
	while(((STK_CTRL>>16)&1)!=1);
 80042f6:	bf00      	nop
 80042f8:	4b09      	ldr	r3, [pc, #36]	; (8004320 <MSYSTICK_stderrorSetBusyWait+0x50>)
 80042fa:	681b      	ldr	r3, [r3, #0]
 80042fc:	0c1b      	lsrs	r3, r3, #16
 80042fe:	f003 0301 	and.w	r3, r3, #1
 8004302:	2b01      	cmp	r3, #1
 8004304:	d1f8      	bne.n	80042f8 <MSYSTICK_stderrorSetBusyWait+0x28>
	STK_CTRL =0;
 8004306:	4b06      	ldr	r3, [pc, #24]	; (8004320 <MSYSTICK_stderrorSetBusyWait+0x50>)
 8004308:	2200      	movs	r2, #0
 800430a:	601a      	str	r2, [r3, #0]
	return L_stderrorError;
 800430c:	7bfb      	ldrb	r3, [r7, #15]
}
 800430e:	4618      	mov	r0, r3
 8004310:	3714      	adds	r7, #20
 8004312:	46bd      	mov	sp, r7
 8004314:	bc80      	pop	{r7}
 8004316:	4770      	bx	lr
 8004318:	e000e014 	.word	0xe000e014
 800431c:	e000e018 	.word	0xe000e018
 8004320:	e000e010 	.word	0xe000e010

08004324 <MSYSTICK_DisableInterrupt>:

void MSYSTICK_DisableInterrupt
(
	void
)
{
 8004324:	b480      	push	{r7}
 8004326:	af00      	add	r7, sp, #0
	
	STK_CTRL &=(~(1<<1));
 8004328:	4b04      	ldr	r3, [pc, #16]	; (800433c <MSYSTICK_DisableInterrupt+0x18>)
 800432a:	681b      	ldr	r3, [r3, #0]
 800432c:	4a03      	ldr	r2, [pc, #12]	; (800433c <MSYSTICK_DisableInterrupt+0x18>)
 800432e:	f023 0302 	bic.w	r3, r3, #2
 8004332:	6013      	str	r3, [r2, #0]
}
 8004334:	bf00      	nop
 8004336:	46bd      	mov	sp, r7
 8004338:	bc80      	pop	{r7}
 800433a:	4770      	bx	lr
 800433c:	e000e010 	.word	0xe000e010

08004340 <MSYSTICK_Delay_Ms>:

void MSYSTICK_Delay_Ms
( 
	u32 ARG_u32Time 
)
{
 8004340:	b580      	push	{r7, lr}
 8004342:	b082      	sub	sp, #8
 8004344:	af00      	add	r7, sp, #0
 8004346:	6078      	str	r0, [r7, #4]
	MSYSTICK_DisableInterrupt();
 8004348:	f7ff ffec 	bl	8004324 <MSYSTICK_DisableInterrupt>
	MSYSTICK_stderrorSetBusyWait(ARG_u32Time * 1000);
 800434c:	687b      	ldr	r3, [r7, #4]
 800434e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004352:	fb02 f303 	mul.w	r3, r2, r3
 8004356:	4618      	mov	r0, r3
 8004358:	f7ff ffba 	bl	80042d0 <MSYSTICK_stderrorSetBusyWait>
}
 800435c:	bf00      	nop
 800435e:	3708      	adds	r7, #8
 8004360:	46bd      	mov	sp, r7
 8004362:	bd80      	pop	{r7, pc}

08004364 <SysTick_Handler>:
	MSYSTICK_stderrorSetBusyWait(ARG_u32Time);
}


void SysTick_Handler(void)
{
 8004364:	b580      	push	{r7, lr}
 8004366:	af00      	add	r7, sp, #0
	
	if(MSYSTICK_u8SelectISR ==0)
 8004368:	4b0b      	ldr	r3, [pc, #44]	; (8004398 <SysTick_Handler+0x34>)
 800436a:	781b      	ldrb	r3, [r3, #0]
 800436c:	2b00      	cmp	r3, #0
 800436e:	d109      	bne.n	8004384 <SysTick_Handler+0x20>
	{
		
		MSYSTICK_pvoidfUserFunctionSysTick();
 8004370:	4b0a      	ldr	r3, [pc, #40]	; (800439c <SysTick_Handler+0x38>)
 8004372:	681b      	ldr	r3, [r3, #0]
 8004374:	4798      	blx	r3
		STK_CTRL &=~(3U);
 8004376:	4b0a      	ldr	r3, [pc, #40]	; (80043a0 <SysTick_Handler+0x3c>)
 8004378:	681b      	ldr	r3, [r3, #0]
 800437a:	4a09      	ldr	r2, [pc, #36]	; (80043a0 <SysTick_Handler+0x3c>)
 800437c:	f023 0303 	bic.w	r3, r3, #3
 8004380:	6013      	str	r3, [r2, #0]
	}
	else
	{
		
	}
}
 8004382:	e006      	b.n	8004392 <SysTick_Handler+0x2e>
	else if(MSYSTICK_u8SelectISR ==1)
 8004384:	4b04      	ldr	r3, [pc, #16]	; (8004398 <SysTick_Handler+0x34>)
 8004386:	781b      	ldrb	r3, [r3, #0]
 8004388:	2b01      	cmp	r3, #1
 800438a:	d102      	bne.n	8004392 <SysTick_Handler+0x2e>
		MSYSTICK_pvoidfUserFunctionSysTick();
 800438c:	4b03      	ldr	r3, [pc, #12]	; (800439c <SysTick_Handler+0x38>)
 800438e:	681b      	ldr	r3, [r3, #0]
 8004390:	4798      	blx	r3
}
 8004392:	bf00      	nop
 8004394:	bd80      	pop	{r7, pc}
 8004396:	bf00      	nop
 8004398:	200000f8 	.word	0x200000f8
 800439c:	200000f4 	.word	0x200000f4
 80043a0:	e000e010 	.word	0xe000e010

080043a4 <MUSART1_voidInit>:

void MUSART1_voidInit
(
	void
)
{
 80043a4:	b480      	push	{r7}
 80043a6:	af00      	add	r7, sp, #0
	/*	baud rate = 9600 */
	USART1 -> BRR = 0x341;
 80043a8:	4b0e      	ldr	r3, [pc, #56]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043aa:	f240 3241 	movw	r2, #833	; 0x341
 80043ae:	609a      	str	r2, [r3, #8]
	/* Enabling Transmitter */
	USART1-> CR[0] |=(1<<3);
 80043b0:	4b0c      	ldr	r3, [pc, #48]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043b2:	68db      	ldr	r3, [r3, #12]
 80043b4:	4a0b      	ldr	r2, [pc, #44]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043b6:	f043 0308 	orr.w	r3, r3, #8
 80043ba:	60d3      	str	r3, [r2, #12]
	/* Enabling Receiver */
	USART1-> CR[0] |=(1<<2);
 80043bc:	4b09      	ldr	r3, [pc, #36]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043be:	68db      	ldr	r3, [r3, #12]
 80043c0:	4a08      	ldr	r2, [pc, #32]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043c2:	f043 0304 	orr.w	r3, r3, #4
 80043c6:	60d3      	str	r3, [r2, #12]
	/* Enabling USART */
	USART1-> CR[0] |=(1<<13);
 80043c8:	4b06      	ldr	r3, [pc, #24]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043ca:	68db      	ldr	r3, [r3, #12]
 80043cc:	4a05      	ldr	r2, [pc, #20]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043ce:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80043d2:	60d3      	str	r3, [r2, #12]
	/* Clearing status register */
	USART1 -> SR = 0;
 80043d4:	4b03      	ldr	r3, [pc, #12]	; (80043e4 <MUSART1_voidInit+0x40>)
 80043d6:	2200      	movs	r2, #0
 80043d8:	601a      	str	r2, [r3, #0]
}
 80043da:	bf00      	nop
 80043dc:	46bd      	mov	sp, r7
 80043de:	bc80      	pop	{r7}
 80043e0:	4770      	bx	lr
 80043e2:	bf00      	nop
 80043e4:	40013800 	.word	0x40013800

080043e8 <MUSART1_voidTransmit>:

void MUSART1_voidTransmit
(
	char arr[]
)
{
 80043e8:	b480      	push	{r7}
 80043ea:	b085      	sub	sp, #20
 80043ec:	af00      	add	r7, sp, #0
 80043ee:	6078      	str	r0, [r7, #4]
	u8 i = 0;
 80043f0:	2300      	movs	r3, #0
 80043f2:	73fb      	strb	r3, [r7, #15]
	while(arr[i] != '\0')
 80043f4:	e00f      	b.n	8004416 <MUSART1_voidTransmit+0x2e>
	{
		USART1 -> DR = arr[i];
 80043f6:	7bfb      	ldrb	r3, [r7, #15]
 80043f8:	687a      	ldr	r2, [r7, #4]
 80043fa:	4413      	add	r3, r2
 80043fc:	781a      	ldrb	r2, [r3, #0]
 80043fe:	4b0c      	ldr	r3, [pc, #48]	; (8004430 <MUSART1_voidTransmit+0x48>)
 8004400:	605a      	str	r2, [r3, #4]
		/*Transmission complete*/
		while((1&((USART1 -> SR)>>6)) == 0);
 8004402:	bf00      	nop
 8004404:	4b0a      	ldr	r3, [pc, #40]	; (8004430 <MUSART1_voidTransmit+0x48>)
 8004406:	681b      	ldr	r3, [r3, #0]
 8004408:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800440c:	2b00      	cmp	r3, #0
 800440e:	d0f9      	beq.n	8004404 <MUSART1_voidTransmit+0x1c>
		i++;
 8004410:	7bfb      	ldrb	r3, [r7, #15]
 8004412:	3301      	adds	r3, #1
 8004414:	73fb      	strb	r3, [r7, #15]
	while(arr[i] != '\0')
 8004416:	7bfb      	ldrb	r3, [r7, #15]
 8004418:	687a      	ldr	r2, [r7, #4]
 800441a:	4413      	add	r3, r2
 800441c:	781b      	ldrb	r3, [r3, #0]
 800441e:	2b00      	cmp	r3, #0
 8004420:	d1e9      	bne.n	80043f6 <MUSART1_voidTransmit+0xe>
	}
}
 8004422:	bf00      	nop
 8004424:	bf00      	nop
 8004426:	3714      	adds	r7, #20
 8004428:	46bd      	mov	sp, r7
 800442a:	bc80      	pop	{r7}
 800442c:	4770      	bx	lr
 800442e:	bf00      	nop
 8004430:	40013800 	.word	0x40013800

08004434 <MUSART1_SetCallBack>:

STD_error_t MUSART1_SetCallBack
(
	void (*ARG_pvoidFunction)(volatile u8* ARG_Pu8Data)
)
{
 8004434:	b480      	push	{r7}
 8004436:	b085      	sub	sp, #20
 8004438:	af00      	add	r7, sp, #0
 800443a:	6078      	str	r0, [r7, #4]
	STD_error_t L_stderrorError=E_NOK;
 800443c:	2300      	movs	r3, #0
 800443e:	73fb      	strb	r3, [r7, #15]

	if(NULL_POINTER != ARG_pvoidFunction)
 8004440:	687b      	ldr	r3, [r7, #4]
 8004442:	2b00      	cmp	r3, #0
 8004444:	d005      	beq.n	8004452 <MUSART1_SetCallBack+0x1e>
	{

		L_stderrorError=E_OK;
 8004446:	2301      	movs	r3, #1
 8004448:	73fb      	strb	r3, [r7, #15]
		MUSART1_pvoidfUserFunctionResive=ARG_pvoidFunction;
 800444a:	4a06      	ldr	r2, [pc, #24]	; (8004464 <MUSART1_SetCallBack+0x30>)
 800444c:	687b      	ldr	r3, [r7, #4]
 800444e:	6013      	str	r3, [r2, #0]
 8004450:	e001      	b.n	8004456 <MUSART1_SetCallBack+0x22>
	}
	else
	{
		L_stderrorError=E_NULL_POINTER;
 8004452:	2302      	movs	r3, #2
 8004454:	73fb      	strb	r3, [r7, #15]
	}

	return L_stderrorError;
 8004456:	7bfb      	ldrb	r3, [r7, #15]
}
 8004458:	4618      	mov	r0, r3
 800445a:	3714      	adds	r7, #20
 800445c:	46bd      	mov	sp, r7
 800445e:	bc80      	pop	{r7}
 8004460:	4770      	bx	lr
 8004462:	bf00      	nop
 8004464:	200000fc 	.word	0x200000fc

08004468 <USART1_IRQHandler>:


void USART1_IRQHandler(void)
{
 8004468:	b580      	push	{r7, lr}
 800446a:	af00      	add	r7, sp, #0
	if(NULL_POINTER != MUSART1_pvoidfUserFunctionResive)
 800446c:	4b18      	ldr	r3, [pc, #96]	; (80044d0 <USART1_IRQHandler+0x68>)
 800446e:	681b      	ldr	r3, [r3, #0]
 8004470:	2b00      	cmp	r3, #0
 8004472:	d02a      	beq.n	80044ca <USART1_IRQHandler+0x62>
	{
		if ((1&((USART1 -> SR)>>5))== 1)
 8004474:	4b17      	ldr	r3, [pc, #92]	; (80044d4 <USART1_IRQHandler+0x6c>)
 8004476:	681b      	ldr	r3, [r3, #0]
 8004478:	095b      	lsrs	r3, r3, #5
 800447a:	f003 0301 	and.w	r3, r3, #1
 800447e:	2b01      	cmp	r3, #1
 8004480:	d123      	bne.n	80044ca <USART1_IRQHandler+0x62>
		{
			MUSART1_u8RecBuffer[MUSART1_RecCounter] = USART1 -> DR;
 8004482:	4b14      	ldr	r3, [pc, #80]	; (80044d4 <USART1_IRQHandler+0x6c>)
 8004484:	6859      	ldr	r1, [r3, #4]
 8004486:	4b14      	ldr	r3, [pc, #80]	; (80044d8 <USART1_IRQHandler+0x70>)
 8004488:	781b      	ldrb	r3, [r3, #0]
 800448a:	b2db      	uxtb	r3, r3
 800448c:	461a      	mov	r2, r3
 800448e:	b2c9      	uxtb	r1, r1
 8004490:	4b12      	ldr	r3, [pc, #72]	; (80044dc <USART1_IRQHandler+0x74>)
 8004492:	5499      	strb	r1, [r3, r2]

			if(MUSART1_u8RecBuffer[MUSART1_RecCounter]=='\n')
 8004494:	4b10      	ldr	r3, [pc, #64]	; (80044d8 <USART1_IRQHandler+0x70>)
 8004496:	781b      	ldrb	r3, [r3, #0]
 8004498:	b2db      	uxtb	r3, r3
 800449a:	461a      	mov	r2, r3
 800449c:	4b0f      	ldr	r3, [pc, #60]	; (80044dc <USART1_IRQHandler+0x74>)
 800449e:	5c9b      	ldrb	r3, [r3, r2]
 80044a0:	b2db      	uxtb	r3, r3
 80044a2:	2b0a      	cmp	r3, #10
 80044a4:	d107      	bne.n	80044b6 <USART1_IRQHandler+0x4e>
			{
				MUSART1_pvoidfUserFunctionResive(MUSART1_u8RecBuffer);
 80044a6:	4b0a      	ldr	r3, [pc, #40]	; (80044d0 <USART1_IRQHandler+0x68>)
 80044a8:	681b      	ldr	r3, [r3, #0]
 80044aa:	480c      	ldr	r0, [pc, #48]	; (80044dc <USART1_IRQHandler+0x74>)
 80044ac:	4798      	blx	r3
				MUSART1_RecCounter=0;
 80044ae:	4b0a      	ldr	r3, [pc, #40]	; (80044d8 <USART1_IRQHandler+0x70>)
 80044b0:	2200      	movs	r2, #0
 80044b2:	701a      	strb	r2, [r3, #0]
 80044b4:	e006      	b.n	80044c4 <USART1_IRQHandler+0x5c>
			}
			else
			{
				MUSART1_RecCounter++;
 80044b6:	4b08      	ldr	r3, [pc, #32]	; (80044d8 <USART1_IRQHandler+0x70>)
 80044b8:	781b      	ldrb	r3, [r3, #0]
 80044ba:	b2db      	uxtb	r3, r3
 80044bc:	3301      	adds	r3, #1
 80044be:	b2da      	uxtb	r2, r3
 80044c0:	4b05      	ldr	r3, [pc, #20]	; (80044d8 <USART1_IRQHandler+0x70>)
 80044c2:	701a      	strb	r2, [r3, #0]
			}
			USART1 -> SR = 0;
 80044c4:	4b03      	ldr	r3, [pc, #12]	; (80044d4 <USART1_IRQHandler+0x6c>)
 80044c6:	2200      	movs	r2, #0
 80044c8:	601a      	str	r2, [r3, #0]

		}
	}
}
 80044ca:	bf00      	nop
 80044cc:	bd80      	pop	{r7, pc}
 80044ce:	bf00      	nop
 80044d0:	200000fc 	.word	0x200000fc
 80044d4:	40013800 	.word	0x40013800
 80044d8:	20000164 	.word	0x20000164
 80044dc:	20000100 	.word	0x20000100

080044e0 <MUART_voidInterruptEnable>:

void MUART_voidInterruptEnable
(
	void
)
{
 80044e0:	b480      	push	{r7}
 80044e2:	af00      	add	r7, sp, #0
	/*PE interrupt enable*/
	/*RXNE interrupt enable*/
	USART1-> CR[0] |=(1<<5)|(1<<8);
 80044e4:	4b04      	ldr	r3, [pc, #16]	; (80044f8 <MUART_voidInterruptEnable+0x18>)
 80044e6:	68db      	ldr	r3, [r3, #12]
 80044e8:	4a03      	ldr	r2, [pc, #12]	; (80044f8 <MUART_voidInterruptEnable+0x18>)
 80044ea:	f443 7390 	orr.w	r3, r3, #288	; 0x120
 80044ee:	60d3      	str	r3, [r2, #12]
}
 80044f0:	bf00      	nop
 80044f2:	46bd      	mov	sp, r7
 80044f4:	bc80      	pop	{r7}
 80044f6:	4770      	bx	lr
 80044f8:	40013800 	.word	0x40013800

080044fc <main>:
/*for test Functionality*/
/*#define SCB_VTOR  *((volatile u32*)0xE000ED08)*/


int main(void)
{
 80044fc:	b580      	push	{r7, lr}
 80044fe:	b082      	sub	sp, #8
 8004500:	af00      	add	r7, sp, #0
	/*For Set vector table*/
	/*SCB_VTOR=0x08003400;*/

	MRCC_stderrorInit(HSI,AHB_PreScaler1,APB_PreScaler1,APB_PreScaler1);
 8004502:	2300      	movs	r3, #0
 8004504:	2200      	movs	r2, #0
 8004506:	2100      	movs	r1, #0
 8004508:	2002      	movs	r0, #2
 800450a:	f7ff fd19 	bl	8003f40 <MRCC_stderrorInit>
	RCC_EnablePeripheralClk(APB2, USART1EN_PER);
 800450e:	210e      	movs	r1, #14
 8004510:	2002      	movs	r0, #2
 8004512:	f7ff fe6f 	bl	80041f4 <RCC_EnablePeripheralClk>
	RCC_EnablePeripheralClk(APB2, GPIOA_PER);
 8004516:	2102      	movs	r1, #2
 8004518:	2002      	movs	r0, #2
 800451a:	f7ff fe6b 	bl	80041f4 <RCC_EnablePeripheralClk>
	RCC_EnablePeripheralClk(APB2, AFIOEN_PER);
 800451e:	2100      	movs	r1, #0
 8004520:	2002      	movs	r0, #2
 8004522:	f7ff fe67 	bl	80041f4 <RCC_EnablePeripheralClk>
	RCC_EnablePeripheralClk(AHB1, FLITFEN_PER);
 8004526:	2104      	movs	r1, #4
 8004528:	2000      	movs	r0, #0
 800452a:	f7ff fe63 	bl	80041f4 <RCC_EnablePeripheralClk>

	MGPIO_stderrorSerialWireJTAGConfiguration(JTAG_DISABLED_AND_SW_ENABLED);
 800452e:	2002      	movs	r0, #2
 8004530:	f7ff fca4 	bl	8003e7c <MGPIO_stderrorSerialWireJTAGConfiguration>

	MSYSTICK_stderrorInit(AHB_DIV_8);
 8004534:	2000      	movs	r0, #0
 8004536:	f7ff fea5 	bl	8004284 <MSYSTICK_stderrorInit>

	MGPIO_stderrorPinModeSelect(GPIOA, PIN1, OUTPUT_PUSH_PULL_SPEED_10MHZ);
 800453a:	2201      	movs	r2, #1
 800453c:	2101      	movs	r1, #1
 800453e:	2000      	movs	r0, #0
 8004540:	f7ff fa80 	bl	8003a44 <MGPIO_stderrorPinModeSelect>


	MGPIO_stderrorPinModeSelect(GPIOA, PIN9, ALTFUN_PUSH_PULL_SPEED_2MHZ);/*Tx*/
 8004544:	220a      	movs	r2, #10
 8004546:	2109      	movs	r1, #9
 8004548:	2000      	movs	r0, #0
 800454a:	f7ff fa7b 	bl	8003a44 <MGPIO_stderrorPinModeSelect>
	MGPIO_stderrorPinModeSelect(GPIOA, PIN10, INPUT_FLOAT);/*Rx*/
 800454e:	2204      	movs	r2, #4
 8004550:	210a      	movs	r1, #10
 8004552:	2000      	movs	r0, #0
 8004554:	f7ff fa76 	bl	8003a44 <MGPIO_stderrorPinModeSelect>

	/*ENABLE SET UART CALLBACK*/
	MUSART1_SetCallBack(APP1_voidFlash);
 8004558:	481c      	ldr	r0, [pc, #112]	; (80045cc <main+0xd0>)
 800455a:	f7ff ff6b 	bl	8004434 <MUSART1_SetCallBack>

	/*ENABLE UART NVIC*/
	MNVIC_stderrorEnableIRQ(USART1);
 800455e:	2025      	movs	r0, #37	; 0x25
 8004560:	f7ff fcb4 	bl	8003ecc <MNVIC_stderrorEnableIRQ>

	/*ENABLE UART INIT*/
	MUSART1_voidInit();
 8004564:	f7ff ff1e 	bl	80043a4 <MUSART1_voidInit>

	/*ENABLE UART ISR*/
	MUART_voidInterruptEnable();
 8004568:	f7ff ffba 	bl	80044e0 <MUART_voidInterruptEnable>


	while(1)
	{
		/*check if update is Done to jump and reset*/
		if(APARES_u8EndRecordFlag()==1)
 800456c:	f7ff f906 	bl	800377c <APARES_u8EndRecordFlag>
 8004570:	4603      	mov	r3, r0
 8004572:	2b01      	cmp	r3, #1
 8004574:	d116      	bne.n	80045a4 <main+0xa8>
		{
			u32 L_u32count =1;
 8004576:	2301      	movs	r3, #1
 8004578:	607b      	str	r3, [r7, #4]

			u16 L_readBuffer=0;
 800457a:	2300      	movs	r3, #0
 800457c:	807b      	strh	r3, [r7, #2]

			while(L_readBuffer==0)
 800457e:	e00c      	b.n	800459a <main+0x9e>
			{
				MFLASH_voidErasePage(63);
 8004580:	203f      	movs	r0, #63	; 0x3f
 8004582:	f7ff f943 	bl	800380c <MFLASH_voidErasePage>

				MFLASH_stderrorWrite32BitData(63, &L_u32count);
 8004586:	1d3b      	adds	r3, r7, #4
 8004588:	4619      	mov	r1, r3
 800458a:	203f      	movs	r0, #63	; 0x3f
 800458c:	f7ff f988 	bl	80038a0 <MFLASH_stderrorWrite32BitData>

				MFLASH_voidReadPage(63, &L_readBuffer);
 8004590:	1cbb      	adds	r3, r7, #2
 8004592:	4619      	mov	r1, r3
 8004594:	203f      	movs	r0, #63	; 0x3f
 8004596:	f7ff fa1f 	bl	80039d8 <MFLASH_voidReadPage>
			while(L_readBuffer==0)
 800459a:	887b      	ldrh	r3, [r7, #2]
 800459c:	2b00      	cmp	r3, #0
 800459e:	d0ef      	beq.n	8004580 <main+0x84>
			}
			/*Reset Request*/
			NVIC_voidResetRequest();
 80045a0:	f7ff fcb8 	bl	8003f14 <NVIC_voidResetRequest>
		{
			/*DO NOTHING*/
		}

		/*NORMAL CODE*/
		MGPIO_stderrorSetPinValueBSSR(GPIOA, PIN1, HIGH);
 80045a4:	2201      	movs	r2, #1
 80045a6:	2101      	movs	r1, #1
 80045a8:	2000      	movs	r0, #0
 80045aa:	f7ff fb95 	bl	8003cd8 <MGPIO_stderrorSetPinValueBSSR>
		MSYSTICK_Delay_Ms(300);
 80045ae:	f44f 7096 	mov.w	r0, #300	; 0x12c
 80045b2:	f7ff fec5 	bl	8004340 <MSYSTICK_Delay_Ms>
		MGPIO_stderrorSetPinValueBSSR(GPIOA, PIN1, LOW);
 80045b6:	2200      	movs	r2, #0
 80045b8:	2101      	movs	r1, #1
 80045ba:	2000      	movs	r0, #0
 80045bc:	f7ff fb8c 	bl	8003cd8 <MGPIO_stderrorSetPinValueBSSR>
		MSYSTICK_Delay_Ms(300);
 80045c0:	f44f 7096 	mov.w	r0, #300	; 0x12c
 80045c4:	f7ff febc 	bl	8004340 <MSYSTICK_Delay_Ms>
		if(APARES_u8EndRecordFlag()==1)
 80045c8:	e7d0      	b.n	800456c <main+0x70>
 80045ca:	bf00      	nop
 80045cc:	080045d1 	.word	0x080045d1

080045d0 <APP1_voidFlash>:
	}
}


void APP1_voidFlash(volatile u8* ARG_Pu8Data)
{
 80045d0:	b580      	push	{r7, lr}
 80045d2:	b082      	sub	sp, #8
 80045d4:	af00      	add	r7, sp, #0
 80045d6:	6078      	str	r0, [r7, #4]
	if(APP1_u8BLWriteReq ==1)
 80045d8:	4b09      	ldr	r3, [pc, #36]	; (8004600 <APP1_voidFlash+0x30>)
 80045da:	781b      	ldrb	r3, [r3, #0]
 80045dc:	b2db      	uxtb	r3, r3
 80045de:	2b01      	cmp	r3, #1
 80045e0:	d104      	bne.n	80045ec <APP1_voidFlash+0x1c>
	{
		MFLASH_voidEraseApp2Section();
 80045e2:	f7ff fa19 	bl	8003a18 <MFLASH_voidEraseApp2Section>

		APP1_u8BLWriteReq = 0;
 80045e6:	4b06      	ldr	r3, [pc, #24]	; (8004600 <APP1_voidFlash+0x30>)
 80045e8:	2200      	movs	r2, #0
 80045ea:	701a      	strb	r2, [r3, #0]
	{
		/*DO NOTHING*/
	}

	/* Parse */
	APARES_voidRecord(ARG_Pu8Data);
 80045ec:	6878      	ldr	r0, [r7, #4]
 80045ee:	f7ff f8a3 	bl	8003738 <APARES_voidRecord>

	MUSART1_voidTransmit("ok");
 80045f2:	4804      	ldr	r0, [pc, #16]	; (8004604 <APP1_voidFlash+0x34>)
 80045f4:	f7ff fef8 	bl	80043e8 <MUSART1_voidTransmit>
}
 80045f8:	bf00      	nop
 80045fa:	3708      	adds	r7, #8
 80045fc:	46bd      	mov	sp, r7
 80045fe:	bd80      	pop	{r7, pc}
 8004600:	20000004 	.word	0x20000004
 8004604:	080046bc 	.word	0x080046bc

08004608 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8004608:	480d      	ldr	r0, [pc, #52]	; (8004640 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800460a:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800460c:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8004610:	480c      	ldr	r0, [pc, #48]	; (8004644 <LoopForever+0x6>)
  ldr r1, =_edata
 8004612:	490d      	ldr	r1, [pc, #52]	; (8004648 <LoopForever+0xa>)
  ldr r2, =_sidata
 8004614:	4a0d      	ldr	r2, [pc, #52]	; (800464c <LoopForever+0xe>)
  movs r3, #0
 8004616:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8004618:	e002      	b.n	8004620 <LoopCopyDataInit>

0800461a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800461a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800461c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800461e:	3304      	adds	r3, #4

08004620 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8004620:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8004622:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8004624:	d3f9      	bcc.n	800461a <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8004626:	4a0a      	ldr	r2, [pc, #40]	; (8004650 <LoopForever+0x12>)
  ldr r4, =_ebss
 8004628:	4c0a      	ldr	r4, [pc, #40]	; (8004654 <LoopForever+0x16>)
  movs r3, #0
 800462a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800462c:	e001      	b.n	8004632 <LoopFillZerobss>

0800462e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800462e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8004630:	3204      	adds	r2, #4

08004632 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8004632:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8004634:	d3fb      	bcc.n	800462e <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8004636:	f000 f811 	bl	800465c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800463a:	f7ff ff5f 	bl	80044fc <main>

0800463e <LoopForever>:

LoopForever:
  b LoopForever
 800463e:	e7fe      	b.n	800463e <LoopForever>
  ldr   r0, =_estack
 8004640:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 8004644:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8004648:	20000008 	.word	0x20000008
  ldr r2, =_sidata
 800464c:	080046c8 	.word	0x080046c8
  ldr r2, =_sbss
 8004650:	20000008 	.word	0x20000008
  ldr r4, =_ebss
 8004654:	20000168 	.word	0x20000168

08004658 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8004658:	e7fe      	b.n	8004658 <ADC1_2_IRQHandler>
	...

0800465c <__libc_init_array>:
 800465c:	b570      	push	{r4, r5, r6, lr}
 800465e:	2600      	movs	r6, #0
 8004660:	4d0c      	ldr	r5, [pc, #48]	; (8004694 <__libc_init_array+0x38>)
 8004662:	4c0d      	ldr	r4, [pc, #52]	; (8004698 <__libc_init_array+0x3c>)
 8004664:	1b64      	subs	r4, r4, r5
 8004666:	10a4      	asrs	r4, r4, #2
 8004668:	42a6      	cmp	r6, r4
 800466a:	d109      	bne.n	8004680 <__libc_init_array+0x24>
 800466c:	f000 f81a 	bl	80046a4 <_init>
 8004670:	2600      	movs	r6, #0
 8004672:	4d0a      	ldr	r5, [pc, #40]	; (800469c <__libc_init_array+0x40>)
 8004674:	4c0a      	ldr	r4, [pc, #40]	; (80046a0 <__libc_init_array+0x44>)
 8004676:	1b64      	subs	r4, r4, r5
 8004678:	10a4      	asrs	r4, r4, #2
 800467a:	42a6      	cmp	r6, r4
 800467c:	d105      	bne.n	800468a <__libc_init_array+0x2e>
 800467e:	bd70      	pop	{r4, r5, r6, pc}
 8004680:	f855 3b04 	ldr.w	r3, [r5], #4
 8004684:	4798      	blx	r3
 8004686:	3601      	adds	r6, #1
 8004688:	e7ee      	b.n	8004668 <__libc_init_array+0xc>
 800468a:	f855 3b04 	ldr.w	r3, [r5], #4
 800468e:	4798      	blx	r3
 8004690:	3601      	adds	r6, #1
 8004692:	e7f2      	b.n	800467a <__libc_init_array+0x1e>
 8004694:	080046c0 	.word	0x080046c0
 8004698:	080046c0 	.word	0x080046c0
 800469c:	080046c0 	.word	0x080046c0
 80046a0:	080046c4 	.word	0x080046c4

080046a4 <_init>:
 80046a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80046a6:	bf00      	nop
 80046a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80046aa:	bc08      	pop	{r3}
 80046ac:	469e      	mov	lr, r3
 80046ae:	4770      	bx	lr

080046b0 <_fini>:
 80046b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80046b2:	bf00      	nop
 80046b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80046b6:	bc08      	pop	{r3}
 80046b8:	469e      	mov	lr, r3
 80046ba:	4770      	bx	lr
